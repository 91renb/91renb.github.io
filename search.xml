<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>小程序入门学习笔记</title>
    <url>/p/20180828-mini-program-beginner-notes.html</url>
    <content><![CDATA[<p>张小龙说过，小程序是一个“为连接线上线下”而生的产品，尤其是有微信支付的加持，微信小程序在线上线下一体方面能力很强，且能构建核心支付交易闭环，这对很多商家有吸引力，目前打开小程序的方式即有：好友分享、扫二维码、用户手动查找、附近的店、微信群分享、以及与公众号的关联等等，能提供大量入口资源。</p>
<h1 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h1><ul>
<li><p>理解微信小程序的架构</p>
<p>三个主要文件格式</p>
<ul>
<li><code>.js</code>后缀的是 脚本文件</li>
<li><code>.json</code>后缀的文件是 配置文件</li>
<li><code>.wxss</code>后缀的是 样式表文件</li>
</ul>
</li>
<li><p>小程序包含一个描述整体程序的 app 和多个描述各自页面的 page。</p>
<p>一个小程序主体部分由三个文件组成，必须放在项目的根目录，如下：    </p>
<ul>
<li><code>app.js</code> 小程序的脚本代码，可以监听并处理小程序的生命周期函数、声明全局变量。 （必填）</li>
<li><code>app.json</code> 是对整个小程序的全局配置 （必填）</li>
<li><code>app.wxss</code> 是整个小程序的公共样式表 （必填）</li>
</ul>
<p>一个小程序页面由四个文件组成，分别是：</p>
<ul>
<li><code>page_name.js</code> 页面逻辑 （必填）</li>
<li><code>page_name.wxml</code>  页面结构 （必填）</li>
<li><code>page_name.wxss</code>  页面样式表 （选填）</li>
<li><code>page_name.json</code>  页面配置 （选填）</li>
</ul>
</li>
<li><p>项目结构</p>
<ul>
<li><p>|— empty-folder/ ·························· 项目所在目录<br>|— pages/ ······································ 页面目录<br>│ |— index/ ··································· index页面<br>│ |  |— index.js ····························· index页面逻辑（脚本文件）</p>
<p> |  |  |—index.json ·························· index页面配置</p>
<p>│ |  |— index.wxml ······················· index页面结构<br>│ |  |─ index.wxss ························ index页面样式<br>│ |─ logs/ ······································· logs页面<br>│ |— logs.js ···································· logs页面逻辑<br>│ |— logs.wxml ····························· logs页面结构<br>│ |— logs.wxss ······························ logs页面样式<br> |— utils/ ·········································· 公共脚本目录<br>│ |— util.js ····································· 工具脚本<br> |— app.js ········································ 应用程序逻辑</p>
<p> |— app.json ··································· 应用程序配置<br> |— app.wxss ·································· 应用程序公共样式</p>
</li>
<li><p>文件说明：</p>
<ul>
<li><p>app.js <code>用于定义整个应用的逻辑</code></p>
<ol>
<li>app函数是一个全局函数</li>
<li>app函数作用就是用来创建一个应用程序实例</li>
<li>每个应用程序都会有他的生命周期</li>
</ol>
</li>
<li><p>app.json <code>全局配置文件,页面的基本配置信息</code></p>
</li>
<li><p>app.wxss <code>css代码，用来设置整个应用的样式</code></p>
</li>
<li><p>index页面：欢迎页</p>
</li>
<li><p>logs 页面：小程序启动日志的展示页</p>
<p>​</p>
</li>
</ul>
</li>
<li><p>页面结构</p>
<ul>
<li>每个页面组件也分为四个文件组成：<ol>
<li>page_name.js 文件：定义页面的逻辑，用于创建页面对象，以及处理页面生命周期控制和数据处理。</li>
<li>page_name.json 文件：<code>页面配置文件</code> 设置当前页面工作时的window的配置，此处会覆盖app.json中的window设置，也就是说只可以设置window中设置的属性。</li>
<li>page_name.wxml 文件：wxml指的是Wei Xin Markup Language。<code>页面结构文件</code>，用于定义页面中元素结构的，语法遵循XML语法，注意是XML语法，不是HTML语法。</li>
<li>page_name.wxss 文件：wxml指的是Wei Xin Style Sheet。<code>样式文件</code>。用于定义页面样式的，语法遵循CSS语法，扩展了CSS基本用法和长度单位（主要就是rpx响应式像素）。</li>
</ol>
</li>
<li>每个文件夹内的文件名次统一，只有后缀名不同，因为json配置文件中最终会将所有的页面整合成一个页面。</li>
<li>页面基本结构，几乎每个小程序都是这个结构：<ol>
<li>nav bar</li>
<li>body</li>
<li>tab bar</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h1><ul>
<li>小程序中的配置文件分为两种：<ol>
<li><code>全局配置文件</code>，根目录下的 app.json</li>
<li><code>页面配置文件</code>，每个页面目录下的 page_name.json</li>
</ol>
</li>
</ul>
<p><code>app.json文件（全局配置）</code></p>
<pre><code class="json">// 提示：这里要是严格的JSON格式，不能写注释，否则编译报错！
{
  // 设置小程序页面文件的路径，指定小程序由哪些页面组成（必填）
  // 格式：路径+文件名；
  // 数组的第一项代表小程序的初始页面。小程序中新增/减少页面，都需要对 pages 数组进行修改。
  // 文件名不需要写文件后缀，因为框架会自动去寻找路径.json,.js,.wxml,.wxss的四个文件进行整合。
  &quot;pages&quot;: [
    &quot;pages/index/index&quot;,
    &quot;pages/logs/index&quot;
  ],
  // 设置页面的窗口表现，如：状态栏、导航条、标题、窗口背景色等（选填）
  &quot;window&quot;: {
    &quot;navigationBarBackgroundColor&quot;: &quot;#000000&quot;,    // 导航栏背景颜色
    &quot;navigationBarTextStyle&quot;: &quot;white&quot;,            // 导航栏标题颜色，仅支持 black/white
    &quot;navigationBarTitleText&quot;: &quot;微信接口功能演示&quot;,  // 导航栏标题文字内容
    &quot;backgroundColor&quot;: &quot;#ffffff&quot;,   // 窗口的背景色
    &quot;backgroundTextStyle&quot;: &quot;dark&quot;   // 下拉背景字体、loading 图的样式，仅支持 dark/light
    &quot;enablePullDownRefresh&quot;: false  // 是否开启下拉刷新
  },
  // 设置底部tabBar的表现（选填）
  &quot;tabBar&quot;: {
    &quot;backgroundColor&quot;: &quot;#ffffff&quot;         // tab 的背景色
    &quot;color&quot;: &quot;#eeeeee&quot;                   // tab 上的文字默认颜色
    &quot;selectedColor&quot;: &quot;#349dda&quot;           // tab 上的文字选中时的颜色
    &quot;borderStyle&quot;: &quot;black&quot;               // tabbar上边框的颜色， 仅支持 black/white
    &quot;list&quot;: [{                           // tab 的列表，2~5个tab
      &quot;pagePath&quot;: &quot;pages/index/index&quot;,   // 页面路径，必须在 pages 中先定义
      &quot;text&quot;: &quot;首页&quot;                     // tab 上按钮文字
      &quot;iconPath&quot;: &quot;aa/a.png&quot;             // 图片路径，icon 大小限制为40kb
      &quot;selectedIconPath&quot;: &quot;aa/b.png&quot;     // 选中时的图片路径，icon 大小限制为40kb
    }, {
      &quot;pagePath&quot;: &quot;pages/logs/logs&quot;,
      &quot;text&quot;: &quot;日志&quot;
    }]
    &quot;position&quot;: &quot;bottom&quot;                 // 设置tabbar的位置：可选值 bottom、top
  },
  // 设置网络超时时间（选填）,默认时间都为：60000毫秒
  &quot;networkTimeout&quot;: {
    &quot;request&quot;: 10000,
    &quot;connectSocket&quot;: 10000,
    &quot;uploadFile&quot;: 10000,
    &quot;downloadFile&quot;: 10000
  },
  // 设置是否开启debug模式，即是否在控制台输出调试信息（选填）
  &quot;debug&quot;: true
}
</code></pre>
<p><code>page_name.json文件（页面配置文件）</code></p>
<pre><code class="json">说明：每一个小程序页面也可以使用.json文件来对本页面的窗口表现进行配置。 页面的配置比app.json全局配置简单得多，只是设置 app.json 中的 window 配置项的内容，页面中配置项会覆盖 app.json 的 window 中相同的配置项。页面的.json只能设置 window 相关的配置项，以决定本页面的窗口表现，所以无需写 window 这个键，如：
{
  &quot;navigationBarBackgroundColor&quot;: &quot;#000000&quot;,    // 导航栏背景颜色
  &quot;navigationBarTextStyle&quot;: &quot;white&quot;,            // 导航栏标题颜色，仅支持 black/white
  &quot;navigationBarTitleText&quot;: &quot;微信接口功能演示&quot;,  // 导航栏标题文字内容
  &quot;backgroundColor&quot;: &quot;#eeeeee&quot;,       // 窗口的背景色 
  &quot;backgroundTextStyle&quot;: &quot;dark&quot;       // 下拉背景字体、loading 图的样式，仅支持 dark/light
  &quot;enablePullDownRefresh&quot;: false      // 是否开启下拉刷新
  &quot;disableScroll&quot;: false              // 设置为 true 则页面整体不能上下滚动；只在 page.json 中有效，无法在 app.json 中设置该项
}
</code></pre>
<h1 id="逻辑层（App-Service）"><a href="#逻辑层（App-Service）" class="headerlink" title="逻辑层（App Service）"></a>逻辑层（App Service）</h1><ul>
<li>小程序开发框架的逻辑层是由JavaScript编写。</li>
<li>逻辑层将数据进行处理后发送给视图层，同时接受视图层的事件反馈。<ul>
<li>增加 <a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/app.html?t=20161222" target="_blank" rel="noopener">App</a> 和 <a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/page.html?t=20161222" target="_blank" rel="noopener">Page</a> 方法，进行程序和页面的注册。</li>
<li>增加 getApp 和 getCurrentPages 方法，分别用来获取 App 实例和当前页面栈。</li>
<li>提供丰富的 <a href="https://mp.weixin.qq.com/debug/wxadoc/dev/api/?t=20161222" target="_blank" rel="noopener">API</a>，如微信用户数据，扫一扫，支付等微信特有能力。</li>
<li>每个页面有独立的<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/module.html?t=20161222#%E6%96%87%E4%BB%B6%E4%BD%9C%E7%94%A8%E5%9F%9F" target="_blank" rel="noopener">作用域</a>，并提供<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/module.html?t=20161222#%E6%A8%A1%E5%9D%97%E5%8C%96" target="_blank" rel="noopener">模块化</a>能力。</li>
<li>由于框架并非运行在浏览器中，所以 JavaScript 在 web 中一些能力都无法使用，如 document，window 等。</li>
<li>开发者写的所有代码最终将会打包成一份 JavaScript，并在小程序启动的时候运行，直到小程序销毁。类似 ServiceWorker，所以逻辑层也称之为 App Service。</li>
</ul>
</li>
</ul>
<h4 id="1-注册程序-—》-app-js文件"><a href="#1-注册程序-—》-app-js文件" class="headerlink" title="1. 注册程序 —》 app.js文件"></a>1. 注册程序 —》 app.js文件</h4><pre><code class="javascript">// app.js
// App(object) 函数用来注册一个小程序。接受一个 object 参数。
// object参数内可以包含多个函数（生命周期函数或自定义函数）。
App({
  // 1. 监听小程序初始化：当小程序初始化完成时，会触发 onLaunch（全局只触发一次）
  onLaunch: function() { 
    // Do something initial when launch.
  },
  // 2. 监听小程序显示：当小程序启动，或从后台进入前台显示，会触发 onShow
  onShow: function() {
      // Do something when show.
  },
  // 3. 监听小程序隐藏：当小程序从前台进入后台，会触发 onHide
  onHide: function() {
      // Do something when hide.
  },
  // 4. 错误监听函数
  onError: function(msg) {
    console.log(msg)
  },
  // 自定义函数（用 this 可以访问）
  myFun: function(msg) {

  },
  globalData: &#39;I am global data&#39;
})
// 在APP()函数内可以设置全局函数和全局数据。
// 在app.js文件内部是通过this获取当前小程序的实例，在该文件外部是通过getApp()函数获取。
</code></pre>
<p>补充：</p>
<pre><code class="javascript">// other.js
// 在APP()函数内部，直接用this就可以获取到小程序实例。
// 在APP()函数外部，我们提供了全局的 getApp() 函数，可以获取到小程序实例。
var appInstance = getApp()
console.log(appInstance.globalData) // I am global data
</code></pre>
<h4 id="2-注册页面-—》-page-name-js文件"><a href="#2-注册页面-—》-page-name-js文件" class="headerlink" title="2. 注册页面 —》 page_name.js文件"></a>2. 注册页面 —》 page_name.js文件</h4><ul>
<li>说明：<code>Page()</code> 函数用来注册一个页面。接受一个 object 参数，其指定页面的初始数据、生命周期函数、事件处理函数等。</li>
</ul>
<pre><code class="javascript">// index.js
Page({
  data: {                             // 页面的初始数据
    text: &#39;init data&#39;,
    array: [{msg: &#39;1&#39;}, {msg: &#39;2&#39;}],
    object: {
      text: &#39;init data&#39;
    }
  },
  onLoad: function(options) {         // 生命周期函数--监听页面加载
    // 一个页面只会调用一次。
    // 接收页面参数可以获取wx.navigateTo和wx.redirectTo及&lt;navigator/&gt;中的 query。
    // Do some initialize when page load.
  },
  onReady: function() {               // 生命周期函数--监听页面初次渲染完成
    // 一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。
    // 对界面的设置如wx.setNavigationBarTitle请在onReady之后设置。
    // Do something when page ready.
  },
  onShow: function() {                // 生命周期函数--监听页面显示
    // 每次打开页面都会调用一次。
    // Do something when page show.
  },
  onHide: function() {                // 生命周期函数--监听页面隐藏
    // 当navigateTo或底部tab切换时调用。
    // Do something when page hide.
  },
  onUnload: function() {              // 生命周期函数--监听页面卸载
    // 当redirectTo或navigateBack的时候调用。
    // Do something when page close.
  },
  onPullDownRefresh: function() {     // 页面相关事件处理函数--监听用户下拉动作
    // 监听用户下拉刷新事件。
    // 需要在config的window选项中开启enablePullDownRefresh。
    // 当处理完数据刷新后，wx.stopPullDownRefresh可以停止当前页面的下拉刷新。
    // Do something when pull down.
  },
  onReachBottom: function() {         // 页面相关事件处理函数--页面上拉触底事件的处理函数
    // Do something when page reach bottom.
  },
  onShareAppMessage: function () {    // 页面相关事件处理函数--用户点击右上角分享
   // 只有定义了此事件处理函数，右上角菜单才会显示“分享”按钮
   // 用户点击分享按钮的时候会调用
   // 此事件需要 return 一个 Object，用于自定义分享内容
    return {
      title: &#39;自定义分享标题&#39;,   // 当前小程序名称
      desc: &#39;自定义分享描述&#39;,
      path: &#39;/page/user?id=123&#39; // 分享路径，当前页面 path ，必须是以 / 开头的完整路径
    }
   // return custom share data when user share.
  },

  // Event handler.
  viewTap: function() {     // 事件处理函数
    console.log(&#39;view tap&#39;)
    // setData 函数用于将数据从逻辑层发送到视图层，同时改变对应的 this.data 的值。
    this.setData({
      text: &#39;Set some data for updating view.&#39;
    })
  },
  customData: {
    hi: &#39;MINA&#39;
  }
})
</code></pre>
<h4 id="事件处理函数"><a href="#事件处理函数" class="headerlink" title="事件处理函数"></a>事件处理函数</h4><ul>
<li>除了初始化数据和生命周期函数，Page 中还可以定义一些特殊的函数：事件处理函数。在渲染层可以在组件中加入<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/event.html?t=20161222" target="_blank" rel="noopener">事件绑定</a>，当达到触发事件时，就会执行 Page 中定义的事件处理函数。</li>
<li>示例代码：</li>
</ul>
<pre><code class="xml">&lt;!--index.wxml  视图层 --&gt;
&lt;view bindtap=&quot;viewTap&quot;&gt; 刷新 &lt;/view&gt;
</code></pre>
<pre><code class="javascript">// index.js  逻辑层
Page({
  viewTap: function() {
    console.log(&#39; 刷新 视图被点击了&#39;)
  }
})
</code></pre>
<h4 id="setData-函数"><a href="#setData-函数" class="headerlink" title="setData() 函数"></a>setData() 函数</h4><p><code>setData()</code> 函数用于将数据从逻辑层发送到视图层，同时改变对应的<code>this.data</code>的值。</p>
<p>注意：</p>
<ul>
<li><p>直接修改 this.data 无效，无法改变页面的状态，还会造成数据不一致。</p>
</li>
<li><p>单次设置的数据不能超过1024kB，请尽量避免一次设置过多的数据。</p>
</li>
<li><p>示例代码：</p>
<pre><code class="xml">&lt;!--index.wxml--&gt;
&lt;view&gt;{{text}}&lt;/view&gt;
&lt;button bindtap=&quot;changeText&quot;&gt; Change normal data &lt;/button&gt;
&lt;view&gt;{{array[0].text}}&lt;/view&gt;
&lt;button bindtap=&quot;changeItemInArray&quot;&gt; Change Array data &lt;/button&gt;
&lt;view&gt;{{object.text}}&lt;/view&gt;
&lt;button bindtap=&quot;changeItemInObject&quot;&gt; Change Object data &lt;/button&gt;
&lt;view&gt;{{newField.text}}&lt;/view&gt;
&lt;button bindtap=&quot;addNewField&quot;&gt; Add new data &lt;/button&gt;
</code></pre>
<pre><code class="javascript">//index.js
Page({
  data: {
    text: &#39;init data&#39;,
    array: [{text: &#39;init data&#39;}],
    object: {
      text: &#39;init data&#39;
    }
  },
  changeText: function() {
    // this.data.text = &#39;changed data&#39;  // bad, it can not work
    this.setData({
      text: &#39;changed data&#39;
    })
  },
  changeItemInArray: function() {
    // you can use this way to modify a danamic data path
    this.setData({
      &#39;array[0].text&#39;:&#39;changed data&#39;
    })
  },
  changeItemInObject: function(){
    this.setData({
      &#39;object.text&#39;: &#39;changed data&#39;
    });
  },
  addNewField: function() {
    this.setData({
      &#39;newField.text&#39;: &#39;new data&#39;
    })
  }
})
</code></pre>
</li>
</ul>
<h4 id="getCurrentPages"><a href="#getCurrentPages" class="headerlink" title="getCurrentPages()"></a>getCurrentPages()</h4><ul>
<li><code>getCurrentPages()</code> 函数用于获取当前页面栈的实例，以数组形式按栈的顺序给出，第一个元素为首页，最后一个元素为当前页面。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">页面跳转</th>
<th style="text-align:center">跳转方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">打开新页面</td>
<td style="text-align:center">调用 API <code>wx.navigateTo</code> 或使用组件 <code>&lt;navigator open-type=&quot;navigate&quot;/&gt;</code></td>
</tr>
<tr>
<td style="text-align:center">页面重定向</td>
<td style="text-align:center">调用 API <code>wx.redirectTo</code> 或使用组件 <code>&lt;navigator open-type=&quot;redirect&quot;/&gt;</code></td>
</tr>
<tr>
<td style="text-align:center">页面返回</td>
<td style="text-align:center">调用 API <code>wx.navigateBack</code> 或用户按左上角返回按钮</td>
</tr>
<tr>
<td style="text-align:center">Tab 切换</td>
<td style="text-align:center">调用 <code>API wx.switchTab</code> 或使用组件<code>&lt;navigator open-type=&quot;switchTab&quot;/&gt;</code> 或用户切换 Tab</td>
</tr>
</tbody>
</table>
<h4 id="3-文件作用域"><a href="#3-文件作用域" class="headerlink" title="3. 文件作用域"></a>3. 文件作用域</h4><ul>
<li>在javaScript 文件中声明的变量和函数只在该文件中有效；不同的文件中可以声明相同名字的变量和函数，不会互相影响。</li>
<li>通过全局函数 <code>getApp()</code>可以获取全局的应用实例，如果需要全局的数据可以在 <code>App()</code> 中设置。</li>
</ul>
<h4 id="4-模块化"><a href="#4-模块化" class="headerlink" title="4. 模块化"></a>4. 模块化</h4><ul>
<li><p>我们可以将一些公共的代码抽离成为一个单独的 js 文件，作为一个模块。模块只有通过 <code>module.exports(推荐)</code> 或者 <code>exports</code> 才能对外暴露接口。</p>
</li>
<li><p>示例代码：</p>
<pre><code class="javascript">// common.js
function sayHello(name) {
  console.log(`Hello ${name} !`)
}
function sayGoodbye(name) {
  console.log(`Goodbye ${name} !`)
}

module.exports.sayHello = sayHello
exports.sayGoodbye = sayGoodbye
</code></pre>
<pre><code class="javascript">// page_name.js
// 在需要使用这些模块的文件中，使用 require(path) 将公共代码引入
var common = require(&#39;common.js&#39;)
Page({
  helloMINA: function() {
    common.sayHello(&#39;MINA&#39;)
  },
  goodbyeMINA: function() {
    common.sayGoodbye(&#39;MINA&#39;)
  }
})
</code></pre>
<p>WXML常用的标签：</p>
<pre><code class="xml">&lt;view&gt;  类似于 &lt;div&gt;
&lt;text&gt; 类似于 &lt;font&gt;&lt;span&gt;
&lt;image&gt; 类似于 &lt;img&gt;
&lt;navigator&gt; 类似于 &lt;a&gt;
</code></pre>
</li>
</ul>
<p>小程序的内容通常不能大于2MB！</p>
<p>css3为了区分伪类和伪元素，伪元素采用双冒号写法。</p>
<pre><code class="\">常见伪类— :hover, :link, :active, :target, :not(), :focus。
常见伪元素— ::first-letter, ::first-line, ::before, ::after, ::selection。
</code></pre>
<p>::before和::after下特有的content，用于在css渲染中向元素逻辑上的头部或尾部添加内容。</p>
<p>这些添加不会出现在DOM中，不会改变文档内容，不可复制，仅仅是在css渲染层加入。</p>
<p>所以不要用:before或:after展示有实际意义的内容，尽量使用它们显示修饰性内容，例如图标。</p>
<p>举例：网站有些联系电话，希望在它们前加一个icon☎，就可以使用:before伪元素，如下：</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS知识点-Runtime</title>
    <url>/p/20180121-ios-runtime.html</url>
    <content><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><ul>
<li><p>带着问题来学习Runtime：</p>
<p>Q1：什么是runtime运行时</p>
<p>Q2：什么是isa指针</p>
<p>Q3：什么是SEL，什么是IMP， 什么是Method</p>
<p>Q4：什么是消息机制</p>
<p>Q5：runtime运行时的使用场景</p>
</li>
</ul>
<h1 id="2-概念"><a href="#2-概念" class="headerlink" title="2.概念"></a>2.概念</h1><ul>
<li><p><strong>runtime</strong></p>
<blockquote>
<p>Objective-C是动态语言，它将很多静态语言在编译和链接时做的事放到了运行时，这个运行时系统就是runtime。</p>
<p>runtime其实就是一个库，它基本上是用C和汇编写的一套API，这个库使C语言有了面向对象的能力。</p>
<p>静态语言：在编译的时候会决定调用哪个函数。</p>
<p>动态语言（OC）：在运行的时候根据函数的名称找到对应的函数来调用。</p>
</blockquote>
</li>
<li><p><strong>isa</strong></p>
<blockquote>
<p>OC中，类和类的实例在本质上没有区别，都是对象，任何对象都有isa指针，它指向类或元类（元类后面会讲解）。</p>
</blockquote>
</li>
<li><p><strong>SEL</strong></p>
<blockquote>
<p>SEL（又叫选择器）是方法的selector的指针。方法的selector表示运行时方法的名字。OC在编译时，会依据每一个方法的名字、参数，生成一个唯一的整型标识(Int类型的地址)，这个标识就是SEL。</p>
</blockquote>
</li>
<li><p><strong>IMP</strong></p>
<blockquote>
<p>IMP是一个函数指针，指向方法最终实现的首地址。SEL就是为了查找方法的最终实现IMP。</p>
</blockquote>
</li>
<li><p><strong>Method</strong></p>
<blockquote>
<p>用于表示类定义中的方法，它的结构体中包含一个SEL和IMP，相当于在SEL和IMP之间作了一个映射。</p>
</blockquote>
</li>
<li><p><strong>消息机制</strong></p>
<blockquote>
<p>任何方法的调用本质就是发送一个消息。编译器会将消息表达式[receiver message]转化为一个消息函数objc_msgSend(receiver, selector)。</p>
</blockquote>
</li>
<li><p><strong>Runtime的使用</strong></p>
<blockquote>
<p>获取属性列表，获取成员变量列表，获得方法列表，获取协议列表，方法交换（黑魔法），动态的添加方法，调用私有方法，为分类添加属性。</p>
</blockquote>
<p>​</p>
</li>
</ul>
<p><strong>Runtime消息传递</strong></p>
<p>一个对象的方法像这样 <code>[obj foo]</code>，编译器转成消息发送 <code>objc_msgSend(obj, foo)</code>，<code>Runtime</code> 时执行的流程是这样的：</p>
<ul>
<li>首先，通过<code>obj</code>的<code>isa</code>指针找到它的 <code>class</code> ;</li>
<li>在 <code>class</code> 的 <code>method list</code> 找 <code>foo</code> ;</li>
<li>如果 <code>class</code> 中没到 <code>foo</code>，继续往它的 <code>superclass</code> 中找 ;</li>
<li>一旦找到 <code>foo</code> 这个函数，就去执行它的实现<code>IMP</code> （方法的实现，IMP是执行方法实现的内存地址的指针）。</li>
</ul>
<h1 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="3.应用场景"></a>3.应用场景</h1><ul>
<li><p>关联对象(Objective-C Associated Objects)给分类增加属性</p>
</li>
<li><p>方法交换 / 黑魔法(Method Swizzling)</p>
</li>
<li><p>实现NSCoding的自动归档和自动解档</p>
</li>
<li><p>实现字典和模型的自动转换(MJExtension)</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1frc63kxno9j31kw10th0b.jpg" alt="Runtime应用场景"></p>
</li>
</ul>
<p><strong>1》关联对象(Objective-C Associated Objects)给分类增加属性</strong></p>
<p>我们都是知道分类是不能自定义属性和变量的。下面通过关联对象实现给分类添加属性。</p>
<p>关联对象Runtime提供了下面几个接口：</p>
<pre><code class="objective-c">// 关联对象
void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)
// 获取关联的对象
id objc_getAssociatedObject(id object, const void *key)
// 移除关联的对象
void objc_removeAssociatedObjects(id object)

// 参数解释
// id object：被关联的对象
// const void *key：关联的key，要求唯一
// id value：关联的对象
// objc_AssociationPolicy policy：内存管理的策略
</code></pre>
<p>Demo：</p>
<pre><code class="objective-c">///-----------------------
/// NSObject+BRModel.h
///-----------------------
#import &lt;Foundation/Foundation.h&gt;

@interface NSObject (BRModel)
/** 1.获取类的属性列表数组 */
+ (NSArray *)br_objectProperties;

/** 2.字典转模型：给定一个字典，返回 self 类对应的模型对象 */
+ (instancetype)br_objectWithDictionary:(NSDictionary *)dict;

@end

///-----------------------
/// NSObject+BRModel.m
///-----------------------
#import &quot;NSObject+BRModel.h&quot;
#import &lt;objc/runtime.h&gt;

const char *kPropertyListKey = &quot;kPropertyListKey&quot;;

@implementation NSObject (BRModel)

/// 所有字典转模型框架的核心算法（这里只是实现简单的字典转模型。扩展：要考虑字典的嵌套）
/// 在字典转模型框架中，如果字典嵌套层次结构非常深，框架由于利用递归实现转换，内存消耗大，执行性能不好！
/// YYModel 因为功能简单（在功能上做了取舍，满足大多数情况下使用），所以速度快！

// 1.动态（通过Runtime形式）获取类的属性列表
+ (NSArray *)br_objectProperties {
    /// 1.利用“关联对象”获取属性的值，如果有，直接返回！(这里获取对象类似于懒加载，只不过分类里面不能创建属性，用“关联对象”来替代)
    /// 这里使用“关联对象”其目的是提高效率（懒加载思想）！
    /**
     *  获取关联对象（相当于属性的getter方法）
     *  参数1：对象
     *  参数2：动态添加属性的key（相当于属性名）
     *  返回值：动态添加的“属性值”
     */
    NSArray *pList = objc_getAssociatedObject(self, kPropertyListKey);
    if (pList != nil) {
        return pList;
    }

    /**
     *  调用运行时方法，获取类的属性列表
     *  class_copyPropertyList():   获取类的 属性 列表方法
     *  class_copyIvarList():       获取类的 成员变量 列表方法
     *  class_copyMethodList():     获取类的 方法 列表方法
     *  class_copyProtocolList():   获取类的 协议 列表方法
     *  参数1：要获取的类
     *  参数2：类属性的个数指针（&amp;属性个数）
     *  返回值：所有属性的数组
     */
    unsigned int count = 0;
    // 获取属性数组（这里objc_property_t接收的是数组，需要带 *）
    objc_property_t *properties = class_copyPropertyList([self class], &amp;count);
    NSMutableArray *propertyNameArr = [[NSMutableArray alloc]init];
    // 遍历属性数组
    for (unsigned int i = 0; i &lt; count; i++) {
        // 1&gt; 获取属性(C语言中的结构体指针，通常不需要带 *)
        objc_property_t property = properties[i];
        // 2&gt; 从property中获取属性的名称（即C语言字符串）
        const char *cName = property_getName(property);
        // 将C语言字符串转成OC字符串
        NSString *name = [NSString stringWithCString:cName encoding:NSUTF8StringEncoding];
        // 3&gt; 添加OC属性名到数组
        [propertyNameArr addObject:name];
    }
    // 释放数组（C语言中用到了包含create/copy/...的方法，都需要释放内存）
    free(properties);

    /**
     *  2.利用“关联对象”保存属性的值
     *  参数1：self 对象
     *  参数2：动态添加属性的key（相当于属性名）
     *  参数3：动态添加属性的值
     *  参数4：对象的引用关系（类似于属性中的 nonatomic,assign/copy/retain）
     */
    objc_setAssociatedObject(self, kPropertyListKey, [propertyNameArr copy], OBJC_ASSOCIATION_RETAIN_NONATOMIC);

    return [propertyNameArr copy];
}

// 2.字典转模型：给定一个字典，返回 self 类对应的模型对象
+ (instancetype)br_objectWithDictionary:(NSDictionary *)dict {
    id object = [[self alloc]init];
    // 获取当前对象的属性列表
    // 优化：使用关联对象 pList 的值保存起来，不用每次都去获取
    NSArray *pList = [self br_objectProperties];
    // 1&gt; 遍历属性数组
    [pList enumerateObjectsUsingBlock:^(id  _Nonnull pName, NSUInteger idx, BOOL * _Nonnull stop) {
        id pValue = [dict objectForKey:pName];
        // 使用KVC给对象属性赋值
        [object setValue:pValue forKey:pName];
    }];
/*
    // 2&gt; 遍历字典
    [dict enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull value, BOOL * _Nonnull stop) {
        if ([pList containsObject:key]) {
            // 使用KVC给对象属性赋值
            [object setValue:value forKey:key];
        }
    }];
*/
    return object;
}

@end
</code></pre>
<p><strong>2》方法交换（黑魔法）</strong></p>
<p>下面就是runtime的重头戏了，被称作黑魔法的方法交换Swizzling。交换方法是在method_exchangeImplementations里发生的。</p>
<p>使用Swizzling的过程中要注意两个问题：</p>
<ul>
<li><p>Swizzling要在+load方法中执行</p>
<blockquote>
<p>运行时会自动调用每个类的两个方法，+load与+initialize。</p>
<p>+load会在main函数之前调用，并且一定会调用。</p>
<p>+initialize是在第一次调用类方法或实例方法之前被调用，有可能一直不被调用。</p>
<p>一般使用Swizzling是为了影响全局，所以为了方法交换一定成功，Swizzling要放在+load中执行。</p>
</blockquote>
</li>
<li><p>Swizzling要在dispatch_once中执行</p>
<blockquote>
<p>Swzzling是为了影响全局，所以只让它执行一次就可以了，所以要放在dispatch_once中。</p>
</blockquote>
</li>
</ul>
<p>Demo：</p>
<pre><code class="objective-c">///-----------------------
/// UIImageView+BRAdd.h
///-----------------------
#import &lt;UIKit/UIKit.h&gt;

@interface UIImageView (BRAdd)
- (void)br_setImage:(UIImage *)image;
@end

///-----------------------
/// UIImageView+BRAdd.m
///-----------------------
#import &quot;UIImageView+BRAdd.h&quot;
#import &lt;objc/runtime.h&gt;

@implementation UIImageView (BRAdd)
/**
 *  load方法 会在类第一次加载的时候（类被加载到运行时的时候）被调用
 *  调用的时间比较靠前，适合在这个方法里做方法交换
 */
+ (void)load {
    // 方法交换应该被保证，在程序中只会执行一次
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        // 1.获取 UIImageView 类的实例方法 setImage:
        Method originalMethod = class_getInstanceMethod([self class], @selector(setImage:));
        // 2.获取 UIImageView 类的实例方法 br_setImage: （这个方法本身定义在分类中，所以能获取到）
        Method swizzledMethod = class_getInstanceMethod([self class], @selector(br_setImage:));
        // 3.交换方法 setImage: 和 br_setImage:
        method_exchangeImplementations(originalMethod, swizzledMethod);
    });
}

// 当在其它位置调用 setImage: 方法时，就会自动调用 br_setImage: 方法
- (void)br_setImage:(UIImage *)image {
    NSLog(@&quot;%s&quot;, __FUNCTION__);

    // 在这里我们可以添加自己想添加的内容...
    // 调整图片大小：生成一张和imageView一样大的图片
    UIImage *newImage = [self newImage:image size:self.bounds.size];

    // 调用系统默认的setImage:方法
    /**
     *  注意：交换了方法（互换身份），这时候调用自己，看起来像是死循环，但是其实自己的实现已经被替换了
     *  调用系统的setImage:方法时，会执行br_setImage:方法
     *  调用br_setImage:方法时，会执行系统的setImage:方法（要注意区分！）
     */
    [self br_setImage:newImage];
}

// 重新生成指定大小的图片
- (UIImage *)newImage:(UIImage *)image size:(CGSize)size {
    UIGraphicsBeginImageContextWithOptions(size, YES, 0);
    // 重新绘制图片
    [image drawInRect:CGRectMake(0, 0, size.width, size.height)];
    // 取得结果
    UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();
    // 关闭上下文
    UIGraphicsEndImageContext();
    return newImage;
}

@end


// 扩展：方法交换还有不少应用场景，比如记录页面被点开的次数：只要在UIViewController的分类的+load中交换viewDidAppear方法，在交换的方法中添加记录代码就可以了。
</code></pre>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS知识点-RunLoop</title>
    <url>/p/20180114-ios-runloop.html</url>
    <content><![CDATA[<h1 id="一、基础篇"><a href="#一、基础篇" class="headerlink" title="一、基础篇"></a>一、基础篇</h1><h3 id="1-RunLoop是什么"><a href="#1-RunLoop是什么" class="headerlink" title="1.RunLoop是什么"></a>1.RunLoop是什么</h3><ul>
<li><p>RunLoop字面意思是跑圈，实际就是运行循环（即死循环）</p>
<blockquote>
<p>其实它内部就是do-while循环,在这个循环内部不断的处理各种任务(比如Source、Timer、Observer)</p>
</blockquote>
</li>
</ul>
<h3 id="2-RunLoop基本作用"><a href="#2-RunLoop基本作用" class="headerlink" title="2.RunLoop基本作用"></a>2.RunLoop基本作用</h3><ul>
<li>保持程序持续运行（保证程序不退出）</li>
<li>处理（监听）APP中的各种事件（如，监听触摸事件、定时器事件、Selector事件）</li>
<li>节省CPU资源，提高程序性能（有事情时就做事情，没事情时就休息待命）</li>
</ul>
<h3 id="3-获取RunLoop对象"><a href="#3-获取RunLoop对象" class="headerlink" title="3.获取RunLoop对象"></a>3.获取RunLoop对象</h3><ul>
<li><p>Foundation框架：</p>
<pre><code class="objective-c">[NSRunLoop currentRunLoop];    // 获得当前线程的RunLoop对象
[NSRunLoop mainRunLoop];     // 获得主线程的RunLoop对象
// NSRunLoop类是OC编写的，是对CFRunLoopRef的一个简单的封装
</code></pre>
</li>
<li><p>Core Foundation框架：</p>
<pre><code class="objective-c">CFRunLoopGetCurrent();    // 获得当前线程的RunLoop对象
CFRunLoopGetMain();     // 获得主线程的RunLoop对象
// CFRunLoopRef是C语言编写的，更底层，开源
</code></pre>
</li>
</ul>
<h1 id="二、提高篇"><a href="#二、提高篇" class="headerlink" title="二、提高篇"></a>二、提高篇</h1><h3 id="1-RunLoop和线程间的关系"><a href="#1-RunLoop和线程间的关系" class="headerlink" title="1.RunLoop和线程间的关系"></a>1.RunLoop和线程间的关系</h3><ul>
<li><p>一个线程对应一个RunLoop（key和value的关系）。</p>
</li>
<li><p>线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop在第一次获取时创建，在线程结束时销毁。</p>
<blockquote>
<p>创建子线程的RunLoop直接调用 <code>[NSRunLoop currentRunLoop];</code>, 这个Get方法是懒加载的。</p>
</blockquote>
</li>
<li><p>主线程的RunLoop默认是自动开启，其它线程（子线程）的RunLoop需要手动开启。</p>
<blockquote>
<p>[[NSRunLoop currentRunLoop] run];  // 手动开启RunLoop</p>
</blockquote>
</li>
<li><p>分析源码：</p>
<pre><code class="c">/**
    iOS 开发中能遇到两个线程对象: pthread_t 和 NSThread。
    可以通过 pthread_main_thread_np() 或 [NSThread mainThread] 来获取主线程；
    通过 pthread_self() 或 [NSThread currentThread] 来获取当前线程。
    CFRunLoop 是基于 pthread 来管理的。

    苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。 这两个函数内部的逻辑大概是下面这样:
*/

/// 全局的Dictionary，key 是 pthread_t（线程）， value 是 CFRunLoopRef（RunLoop）
static CFMutableDictionaryRef loopsDic;
/// 访问 loopsDic 时的锁
static CFSpinLock_t loopsLock;

/// 获取一个 pthread 对应的 RunLoop。
CFRunLoopRef _CFRunLoopGet(pthread_t thread) {
    OSSpinLockLock(&amp;loopsLock);

    if (!loopsDic) {
        // 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。
        loopsDic = CFDictionaryCreateMutable();
        CFRunLoopRef mainLoop = _CFRunLoopCreate();
        CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop);
    }

    /// 直接从 Dictionary 里获取。
    CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread));

    if (!loop) {
        /// 取不到时，创建一个
        loop = _CFRunLoopCreate();
        CFDictionarySetValue(loopsDic, thread, loop);
        /// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。
        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);
    }

    OSSpinLockUnLock(&amp;loopsLock);
    return loop;
}

CFRunLoopRef CFRunLoopGetMain() {
    return _CFRunLoopGet(pthread_main_thread_np());
}

CFRunLoopRef CFRunLoopGetCurrent() {
    return _CFRunLoopGet(pthread_self());
}
</code></pre>
</li>
</ul>
<h3 id="2-RunLoop相关类"><a href="#2-RunLoop相关类" class="headerlink" title="2.RunLoop相关类"></a>2.RunLoop相关类</h3><ul>
<li><p>Core Foundation中关于RunLoop的5个类：</p>
<pre><code class="c">CFRunLoopRef        // 获得当前RunLoop和主RunLoop
CFRunLoopModeRef    // 代表的是RunLoop的运行模式
CFRunLoopSourceRef    // 事件源，输入源
CFRunLoopTimerRef        // 定时器时间
CFRunLoopObserverRef    // 观察者，能够监听RunLoop的状态改变
</code></pre>
<p>RunLoop的相关类之间的关系如下:</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fr0k30kx1sj30af086q42.jpg" alt="RunLoop相关类"></p>
<blockquote>
<p>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。但RunLoop每次只能选择一个模式运行。要保证运行循环RunLoop不退出，每个模式里面至少存在一个Source或者一个Timer，Observer可以有也可以没有，只是监听RunLoop的运行状态。</p>
</blockquote>
<p><strong>CFRunLoopSourceRef</strong> 是事件产生的地方。Source有两个版本：Source0 和 Source1。</p>
<blockquote>
<p>Source0：基于用户主动触发的事件（触摸事件，performSelector 都会触发Source0事件）</p>
<p>​    点击button 或点击屏幕，当点击屏幕时，手指和屏幕产生一个事件，这个事件会自动打包生成一个Source0事件</p>
<p>Source1：基于Port的线程间通信（与内核相关，自发调用的）<br>注意：Source1在处理的时候会分发一些操作给Source0去处理</p>
</blockquote>
<p><strong>CFRunLoopTimerRef</strong> 是基于时间的触发器。</p>
<blockquote>
<p>其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。</p>
</blockquote>
<p><strong>CFRunLoopObserverRef</strong> 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个：</p>
<pre><code class="objective-c">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {
    kCFRunLoopEntry         = (1UL &lt;&lt; 0), // 即将进入运行循环
    kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1), // 即将处理定时器事件
    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理输入源事件
    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠
    kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6), // 刚从休眠中唤醒
    kCFRunLoopExit          = (1UL &lt;&lt; 7), // 退出运行循环
    kCFRunLoopAllActivities = 0x0FFFFFFFU // 运行循环所有活动
};
</code></pre>
<p><strong>添加观察者到运行循环的代码:</strong></p>
<pre><code class="objective-c">// 监听RunLoop的各种活动状态(包括唤醒，休息，以及处理各种事件等...)
- (void)observerRunLoopActivity {
    /* 
     1.创建观察者
         参数1: 分配内存空间的方式,传默认
         参数2: RunLoop的运行状态
         参数3: 是否持续观察
         参数4: 优先级,传0
         参数5: 观察者观测到状态改变时触发的方法
     */
    CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(), kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) {
        switch (activity) {
            case kCFRunLoopEntry:
                NSLog(@&quot;RunLoop进入&quot;);
                break;
            case kCFRunLoopBeforeTimers:
                NSLog(@&quot;RunLoop要处理定时器（Timers）事件了&quot;);
                break;
            case kCFRunLoopBeforeSources:
                NSLog(@&quot;RunLoop要处理输入源（Sources）事件了&quot;);
                break;
            case kCFRunLoopBeforeWaiting:
                NSLog(@&quot;RunLoop要休息了&quot;);
                break;
            case kCFRunLoopAfterWaiting:
                NSLog(@&quot;RunLoop醒来了&quot;);
                break;
            case kCFRunLoopExit:
                NSLog(@&quot;RunLoop退出了&quot;);
                break;
            default:
                break;
        }
    });
    /* 
     2.添加观察者到运行循环
         参数1: 要监听哪个RunLoop, 传入当前的运行循环
         参数2: 观察者/监听者, 观察运行循环的各种状态
         参数3: 运行循环的模式，要监听RunLoop在哪种运行模式下的状态
     */
    CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode);
      /** 
       3.释放观察者 
       CF的内存管理（Core Foundation）:凡是带有Create、Copy、Retain等字眼的函数，创建出来的对象，都需要在最后做一次release
      */
    CFRelease(observer);
}
</code></pre>
</li>
</ul>
<h3 id="3-RunLoop的model"><a href="#3-RunLoop的model" class="headerlink" title="3.RunLoop的model"></a>3.RunLoop的model</h3><ul>
<li><p>RunLoop 有五种运行模式，其中我们常用的是1、2、5这三个。</p>
<pre><code class="objective-c">kCFRunLoopDefaultMode    // 1&gt; App的默认Mode，通常主线程是在这个Mode下运行
UITrackingRunLoopMode    // 2&gt; 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响
UIInitializationRunLoopMode    // 3&gt; 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用
GSEventReceiveRunLoopMode    // 4&gt; 接受系统事件的内部 Mode，通常用不到
kCFRunLoopCommonModes        // 5&gt; 这是一个占位用的Mode，不是一种真正的Mode
</code></pre>
</li>
<li><p>Model间的切换：</p>
<blockquote>
<p>我们平时在开发中一定遇到过，当我们使用NSTimer每一段时间执行一些事情时滑动UIScrollView，NSTimer就会暂停，当我们停止滑动以后，NSTimer又会重新恢复的情况</p>
</blockquote>
<pre><code class="objective-c">// 创建定时器并添加到RunLoop
// [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(show) userInfo:nil repeats:YES];

NSTimer *timer = [NSTimer timerWithTimeInterval:2.0 target:self selector:@selector(show) userInfo:nil repeats:YES];
// 把定时器添加到RunLoop中
// 1.NSDefaultRunLoopMode 默认运行模式，此时定时器任务只会在默认模式下执行
[[NSRunLoop mainRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode]; 

// 当scrollView滑动的时候，timer失效，停止滑动时，timer恢复
// 原因：当scrollView滑动的时候，RunLoop的Mode会自动切换成UITrackingRunLoopMode模式，因此timer失效，当停止滑动，RunLoop又会切换回NSDefaultRunLoopMode模式，因此timer又会重新启动了

// 2. UITrackingRunLoopMode 界面跟踪模式，此时定时器任务只会在滑动scrollView时执行
[[NSRunLoop mainRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];

// 3. 那个如何让timer在两个模式下都可以运行呢？(即滚动视图时，不会对定时器产生影响)
// 3.1 在两个模式下都添加timer 是可以的，但是timer添加了两次，并不是同一个timer
// 3.2 使用占位的运行模式 NSRunLoopCommonModes标记，凡是被打上NSRunLoopCommonModes标记的都可以运行，因此也就是说如果我们使用NSRunLoopCommonModes，timer可以在UITrackingRunLoopMode，kCFRunLoopDefaultMode两种模式下运行
[[NSRunLoop mainRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];
</code></pre>
<blockquote>
<p>在实际开发中，一般不把timer放到主线程的RunLoop中，因为主线程在执行阻塞的任务时，timer计时会不准。<br>如何让计时准确？如果timer在主线程中阻塞了怎么办？<br>1》放入子线程中(即要开辟一个新的线程，但是成本是需要开辟一个新的线程)<br>2》写一种跟RunLoop没有关系的计时，即GCD。(不会阻塞，推荐使用这种)</p>
</blockquote>
<pre><code class="objective-c">// GCD定时器(常用)
// 创建队列
dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
// 1.创建一个GCD定时器
/*
 第一个参数:表明创建的是一个定时器
 第四个参数:队列
 */
dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);
// 需要对timer进行强引用，保证其不会被释放掉，才会按时调用block块
// 局部变量，让指针强引用
self.timer = timer;
// 2.设置定时器的开始时间,间隔时间,精准度
/*
 第1个参数:要给哪个定时器设置
 第2个参数:开始时间
 第3个参数:间隔时间
 第4个参数:精准度 一般为0 在允许范围内增加误差可提高程序的性能
 GCD的单位是纳秒 所以要*NSEC_PER_SEC
 */
dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 2.0 * NSEC_PER_SEC, 0 * NSEC_PER_SEC);

// 3.设置定时器要执行的事情
dispatch_source_set_event_handler(timer, ^{
    NSLog(@&quot;---%@--&quot;,[NSThread currentThread]);
    // 取消定时
      if (判断条件) {
        dispatch_source_cancel(timer);
          self.timer = nil;
      }
});
// 4.启动
dispatch_resume(timer);
</code></pre>
</li>
</ul>
<h3 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="4.应用场景"></a>4.应用场景</h3><ul>
<li><p><strong>定时器</strong>：实例化定时器并指定监听方法后，需要把定时器加到RunLoop上。加到RunLoop上之后，才能在每个时间触发的时候去监听事件。</p>
<pre><code class="objective-c">self.timer = [NSTimer timerWithTimeInterval:2.0 target:self selector:@selector(show) userInfo:nil repeats:YES];
[[NSRunLoop mainRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode]; 
</code></pre>
<p>使用定时器还有一个细节：就是在定时器不使用的时候，必须要销毁，否则会产生循环引用。</p>
<blockquote>
<p>target后有一个self，定时器会对self强引用；viewController本身也会对定时器强引用（定时器通常会保存到viewController的实例变量/属性中），所以就会产生循环引用。</p>
</blockquote>
</li>
<li><p><strong>常驻线程</strong>：永远活着的线程。开启一个子线程，再手动开启这个子线程的RunLoop，这个子线程就是常驻线程。</p>
<blockquote>
<p>常驻线程的生命周期跟APP相同。跟主线程并行，永远不会被销毁，一直在后台默默的做一些事情。（常驻线程的使用一般比较少，在实际开发中基本上没有这种需求）</p>
<p>在子线程里面也有运行循环（RunLoop），这个运行循环（RunLoop）默认不被开启；只有我们调用它的时候才会被开启（即需要手动开启）。</p>
</blockquote>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fr0pp40721j30yb0oqwny.jpg" alt="常驻线程"></p>
<p>特别注意：</p>
<blockquote>
<p>在启动RunLoop之前建议用 @autoreleasepool {…}包裹。</p>
<p>意义：创建一个大释放池，释放{}期间创建的临时对象，一般好的框架的作者都会这么做。</p>
</blockquote>
<pre><code class="objective-c">- (void)executeTask {
    @autoreleasepool {
        NSTimer *timer = [NSTimer timerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];
        [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];
        [[NSRunLoop currentRunLoop] run];
    }
}
</code></pre>
</li>
<li><p><strong>自动释放池</strong></p>
<pre><code>Q：autoreleasePool对象是什么时候释放的？
A：自动释放池的释放和创建与RunLoop有关。
    当RunLoop开启时，就会自动创建一个自动释放池。
    当Runloop准备休眠的时候，会释放旧的autoreleasePool对象，再重新创建一个新的空的autoreleasePool对象。
    当RunLoop从休眠中被唤醒的时候，Timer,Source等新的事件就会放到新的自动释放池中。
    当Runloop即将退出的时候，会释放掉相关所有的autoreleasePool对象。
</code></pre><blockquote>
<p>注意：只有主线程的RunLoop会默认启动。也就意味着会自动创建自动释放池，子线程需要在线程调度方法中手动添加自动释放池。</p>
</blockquote>
</li>
<li><p><strong>performSelector方法</strong></p>
<p>performSelector其实是创建了一个Timer，然后添加到当前的线程中。如果当前线程没有Runloop，这个方法则走不通的。</p>
<pre><code class="objective-c">// 可以设置只在某个运行模式（modes）下执行方法（aSelector）
- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay inModes:(NSArray&lt;NSRunLoopMode&gt; *)modes;
- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay;
</code></pre>
</li>
<li><p>用于Socket开发：使用RunLoop能够监听网络端口数据的接收与发送情况。（平常企业开发中用Socket开发比较少，通常是做硬件通讯的时候，用得比较多。比如：智能家居开发、游戏机等）</p>
</li>
<li><p>iOS中默认开启的事件循环，保证主线程不退出。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fr0ghscv17j30wu0dzq79.jpg" alt="重新启动"></p>
<blockquote>
<p>第14行代码的UIApplicationMain函数内部就启动了一个RunLoop</p>
<p>所以UIApplicationMain函数一直没有返回，保持了程序的持续运行</p>
<p>这个默认启动的RunLoop是跟主线程相关联的。</p>
</blockquote>
</li>
</ul>
<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><ul>
<li><p>RunLoop知识点的大致框架：</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fr0xlhhk6gj310f0z0jwb.jpg" alt="RunLoop知识点的大致框架"></p>
</li>
<li><p>思考：以后为了增加用户体验，在用户UI交互的时候不做事件处理，我们可以把需要做的操作放到NSDefaultRunLoopMode。</p>
</li>
<li><p>RunLoop处理逻辑流程图：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fr2q0lmuafj30kr0kq0v2.jpg" alt="RunLoop处理逻辑流程图"></p>
</li>
</ul>
<p>在实际中的使用场景其实很明确了, 在程序中中有大量临时变量(循环/遍历中)的时候最好手动创建autoreleasepool{}</p>
<h1 id="四、面试题"><a href="#四、面试题" class="headerlink" title="四、面试题"></a>四、面试题</h1><ol>
<li>讲讲 RunLoop，项目中有用到吗？</li>
<li>RunLoop内部实现逻辑？</li>
<li>Runloop和线程的关系？</li>
<li>timer 与 Runloop 的关系？</li>
<li>程序中添加每3秒响应一次的NSTimer，当拖动tableview时timer可能无法响应要怎么解决？</li>
<li>Runloop 是怎么响应用户操作的， 具体流程是什么样的？</li>
<li>说说RunLoop的几种状态？</li>
<li>Runloop的mode作用是什么？</li>
</ol>
<ul>
<li>main函数中的autoreleasepool的作用?</li>
<li>系统的autoreleasepool我们自己创建的autoreleasepool释放时机差别在哪?</li>
<li>在ARC的环境中, 什么情况下需要使用autoreleasepool? 不使用autoreleasepool变量什么时候会被释放?</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>如何收集线上程序的bug</title>
    <url>/p/20180112-collection-online-program-bug.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Q：程序上线后，如何收集错误信息？</p>
<p>A：使用第三方框架：<code>bugly</code>（腾讯出的） 、友盟…</p>
<ul>
<li>用途：应用程序上架了后，也可以知道崩溃地方在哪里。</li>
<li>查看崩溃日志（收集错误信息）是一些有经验的程序员每天必备的工作。（一般是用户量比较大的APP）</li>
</ul>
<h1 id="bugly的使用"><a href="#bugly的使用" class="headerlink" title="bugly的使用"></a>bugly的使用</h1><ul>
<li><p>进入官方网站：<a href="http://bugly.qq.com" target="_blank" rel="noopener">http://bugly.qq.com</a></p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fqzdevpqh3j30zg0kkafl.jpg" alt="官方网站"></p>
</li>
<li><p>登录（直接使用QQ登录），新建产品</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fqzdhqzr0dj30ze0kk0uv.jpg" alt="新建产品"></p>
</li>
<li><p>新建产品成功后，选择你要接入的功能类型（这里我选择异常上报）</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fqzdkks3a7j30zb0kiwi5.jpg" alt="接入引导"></p>
</li>
<li><p>进入SDK下载页面，找到你要集成的SDK，点击使用指南，按文档说明进行接入。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fqzdsms3bjj30zh0kl0y1.jpg" alt="SDK下载页面"></p>
<p>​</p>
</li>
<li><p>使用CocoaPods集成：<code>pod &#39;Bugly&#39;</code></p>
<blockquote>
<p>初始化Bugly的方法最好放在程序启动方法的第一句位置，因为这样后面的代码就都可以监听到。</p>
</blockquote>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fqzmqi7x2zj31090hugop.jpg" alt="Demo"></p>
</li>
<li><p>进入我的产品，点击设置，可获取AppID</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fqze5bmtrhj30zk0cnq54.jpg" alt="我的产品"></p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fqze6a4304j30zd0f7jtt.jpg" alt="产品设置"></p>
</li>
<li><p>Command+R 运行程序</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fqzejkfoz6j30t70k878w.jpg" alt="运行程序"></p>
</li>
<li><p>程序崩溃</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fqzelcjx23j30tz0l0k1s.jpg" alt="程序崩溃"></p>
</li>
<li><p>去Bugly查看崩溃信息</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fqzewfbj00j30zj0kl78a.jpg" alt="奔溃分析"></p>
</li>
<li><p>点击查看列表详情</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fqzfgnug84j31kw43dhdt.jpg" alt="列表详情"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS干货</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS程序调试</title>
    <url>/p/20180110-ios-program-debugging.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li>在iOS开发中如何调试程序？<ul>
<li>调用堆栈的调试技巧</li>
<li>打全局断点</li>
<li>局部断点</li>
<li>lldb</li>
<li>instrument：Time Profile / Core Animation / 内存泄露</li>
</ul>
</li>
</ul>
<h1 id="1-调用堆栈的调试技巧"><a href="#1-调用堆栈的调试技巧" class="headerlink" title="1.调用堆栈的调试技巧"></a>1.调用堆栈的调试技巧</h1><ul>
<li>演示Demo：</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fqz822zgdnj30ts0l8jw9.jpg" alt="4FD54FFA-BE95-4EA2-A26E-CDD72BE4CA2F"></p>
<ul>
<li>Command+R，程序一运行就Crash！</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fqz8arhem6j30ts0n5dp3.jpg" alt="16C11D5E-B62B-47BA-8565-73C3E1F7F009"></p>
<ul>
<li>查看 <strong><code>reason:</code> </strong>，初步分析Crash原因：</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fqz9ksu86nj30qq0e5tcz.jpg" alt></p>
<pre><code>reason: &#39;*** -[__NSPlaceholderArray initWithObjects:count:]: attempt to insert nil object from objects[1]&#39;
// 错误原因：试图在数组索引为1的位置插入nil空对象。
</code></pre><ul>
<li>接下来，去找是在程序哪里插入了nil空对象。查看程序的调用堆栈（先执行的方法在下面，后执行的方法在上面）</li>
</ul>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fqza5nwwncj30ql0jqqib.jpg" alt="C76F31AD-C1CF-4191-A663-AB5BC9B6A154"></p>
<ul>
<li>根据reason的提示，从exception堆栈的附近定位到可能出现Crash的方法！</li>
</ul>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fqzaicfkivj30jv0b17ba.jpg" alt="00B2B7C9-A558-4DD0-A35B-C2C2CB6B0B5A"></p>
<ul>
<li>查看调用堆栈，发现调用  <code>[NSArray arrayWithObjects:count:]</code>  方法后出现了崩溃，继续查看下面的方法，就可以轻易的定位到 <strong>ViewController</strong> 中的 <code>testCrash</code> 方法</li>
</ul>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fqzb1d9xabj30qp0hcaf9.jpg" alt="9F6E0171-7E73-4627-B695-BE7955B8FDFD"></p>
<ul>
<li>注意：在真机上调试，只显示错误信息，不显示详细的调用堆栈内容！</li>
</ul>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fqzb7080izj30o703v788.jpg" alt="7B19A02F-2040-42B6-9132-6234A1B1906E"></p>
<h1 id="2-打全局断点"><a href="#2-打全局断点" class="headerlink" title="2.打全局断点"></a>2.打全局断点</h1><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fqzbidi9ctj30qp0kfn29.jpg" alt="A3999DC5-E303-47BD-A5BD-C54CDAFB6CDD"></p>
<ul>
<li>添加全局断点后，直接Command+R运行</li>
</ul>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fqzblplalbj30ts0m0gub.jpg" alt="ACD1928C-A23F-4A63-A0F4-33E4764471C7"></p>
<ul>
<li>打全局断点后，直接就定位到错误行代码！</li>
</ul>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><ul>
<li><p>程序Crash后，可以从控制台查看调用堆栈信息。也可以从左边面板查看调用堆栈信息。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fr0eailem9j30w90n0793.jpg" alt="查看调用堆栈信息"></p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fr0eruj0a8j30w90n078w.jpg" alt="可以看到源程序的堆栈"></p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fr0ep2fz2gj30x10nswla.jpg" alt="只能看到汇编语言的堆栈"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS干货</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS面试题-(1)基础篇</title>
    <url>/p/20171202-ios-interview-question-1.html</url>
    <content><![CDATA[<ol>
<li><p><strong>设计模式是什么？ 你知道哪些设计模式，并简要叙述？</strong></p>
<pre><code>设计模式是一种编码经验，就是用比较成熟的逻辑去处理某一种类型的事情。
1). MVC模式：Model View Control，把模型 视图 控制器 层进行解耦合编写。
2). MVVM模式：Model View ViewModel 把模型 视图 业务逻辑 层进行解耦和编写。
3). 单例模式：通过static关键词，声明全局变量。在整个进程运行期间只会被赋值一次。
4). 观察者模式：KVO是典型的通知模式，观察某个属性的状态，状态发生变化时通知观察者。
5). 委托模式：代理+协议的组合。实现1对1的反向传值操作。
6). 工厂模式：通过一个类方法，批量的根据已有模板生产对象。
</code></pre></li>
<li><p><strong>MVC 和 MVVM 的区别</strong></p>
<pre><code>1). MVVM是对胖模型进行的拆分，其本质是给控制器减负，将一些弱业务逻辑放到VM中去处理。
2). MVC是一切设计的基础，所有新的设计模式都是基于MVC进行的改进。
</code></pre></li>
<li><p><strong>#import跟 #include 有什么区别，@class呢，#import&lt;&gt; 跟 #import””有什么区别？</strong></p>
<pre><code>答：
1). #import是Objective-C导入头文件的关键字，#include是C/C++导入头文件的关键字，使用#import头文件会自动只导入一次，不会重复导入。
2). @class告诉编译器某个类的声明，当执行时，才去查看类的实现文件，可以解决头文件的相互包含。
3). #import&lt;&gt;用来包含系统的头文件，#import””用来包含用户头文件。
</code></pre></li>
<li><p><strong>frame 和 bounds 有什么不同？</strong></p>
<pre><code>frame指的是：该view在父view坐标系统中的位置和大小。(参照点是父view的坐标系统)
bounds指的是：该view在本身坐标系统中的位置和大小。(参照点是本身坐标系统)
</code></pre></li>
<li><p><strong>Objective-C的类可以多重继承么？可以实现多个接口么？Category是什么？重写一个类的方式用继承好还是分类好？为什么？</strong></p>
<pre><code>答：Objective-C的类不可以多重继承；可以实现多个接口（协议）；Category是类别；一般情况用分类好，用Category去重写类的方法，仅对本Category有效，不会影响到其他类与原有类的关系。
</code></pre></li>
<li><p><strong>@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的</strong></p>
<pre><code>@property 的本质是什么？
    @property = ivar + getter + setter;
“属性” (property)有两大概念：ivar（实例变量）、getter+setter（存取方法）

“属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。
</code></pre></li>
<li><p><strong>@property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？</strong></p>
<pre><code>属性可以拥有的特质分为四类:
1.原子性--- nonatomic 特质
2.读/写权限---readwrite(读写)、readonly (只读)
3.内存管理语义---assign、strong、 weak、unsafe_unretained、copy
4.方法名---getter=&lt;name&gt; 、setter=&lt;name&gt;
5.不常用的：nonnull,null_resettable,nullable
</code></pre></li>
<li><p><strong>属性关键字 readwrite，readonly，assign，retain，copy，nonatomic 各是什么作用，在那种情况下用？</strong></p>
<pre><code>答：
1). readwrite 是可读可写特性。需要生成getter方法和setter方法。
2). readonly 是只读特性。只会生成getter方法，不会生成setter方法，不希望属性在类外改变。
3). assign 是赋值特性。setter方法将传入参数赋值给实例变量;仅设置变量时,assign用于基本数据类型。
4). retain(MRC)/strong(ARC) 表示持有特性。setter方法将传入参数先保留，再赋值，传入参数的retaincount会+1。
5). copy 表示拷贝特性。setter方法将传入对象复制一份，需要完全一份新的变量时。
6). nonatomic 非原子操作。决定编译器生成的setter和getter方法是否是原子操作，atomic表示多线程安全，一般使用nonatomic，效率高。
</code></pre></li>
<li><p><strong>什么情况使用 weak 关键字，相比 assign 有什么不同？</strong></p>
<pre><code>1.在 ARC 中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak 来解决,比如: delegate 代理属性。
2.自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak,自定义 IBOutlet 控件属性一般也使用 weak；当然，也可以使用strong。

IBOutlet连出来的视图属性为什么可以被设置成weak?
    因为父控件的subViews数组已经对它有一个强引用。

不同点：
assign 可以用非 OC 对象，而 weak 必须用于 OC 对象。
weak 表明该属性定义了一种“非拥有关系”。在属性所指的对象销毁时，属性值会自动清空(nil)。
</code></pre></li>
<li><p><strong>怎么用 copy 关键字？</strong></p>
<pre><code>用途：
  1. NSString、NSArray、NSDictionary 等等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary；
  2. block 也经常使用 copy 关键字。

说明：
  block 使用 copy 是从 MRC 遗留下来的“传统”,在 MRC 中,方法内部的 block 是在栈区的,使用 copy 可以把它放到堆区.在 ARC 中写不写都行：对于 block 使用 copy 还是 strong 效果是一样的，但写上 copy 也无伤大雅，还能时刻提醒我们：编译器自动对 block 进行了 copy 操作。如果不写 copy ，该类的调用者有可能会忘记或者根本不知道“编译器会自动对 block 进行了 copy 操作”，他们有可能会在调用之前自行拷贝属性值。这种操作多余而低效。
</code></pre></li>
<li><p><strong>用@property声明的 NSString / NSArray / NSDictionary 经常使用 copy 关键字，为什么？如果改用strong关键字，可能造成什么问题？</strong></p>
<pre><code class="objective-c">答：用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作（就是把可变的赋值给不可变的），为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。

1. 因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本。
2. 如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性。

//总结：使用copy的目的是，防止把可变类型的对象赋值给不可变类型的对象时，可变类型对象的值发送变化会无意间篡改不可变类型对象原来的值。
</code></pre>
</li>
<li><p><strong>浅拷贝和深拷贝的区别？</strong></p>
<pre><code>答：
浅拷贝：只复制指向对象的指针，而不复制引用对象本身。
深拷贝：复制引用对象本身。内存中存在了两份独立对象本身，当修改A时，A_copy不变。
</code></pre></li>
<li><p><strong>系统对象的 copy 与 mutableCopy 方法</strong></p>
<pre><code class="objective-c">不管是集合类对象（NSArray、NSDictionary、NSSet ... 之类的对象），还是非集合类对象（NSString, NSNumber ... 之类的对象），接收到copy和mutableCopy消息时，都遵循以下准则：
1. copy 返回的是不可变对象（immutableObject）；如果用copy返回值调用mutable对象的方法就会crash。
2. mutableCopy 返回的是可变对象（mutableObject）。

一、非集合类对象的copy与mutableCopy
  在非集合类对象中，对不可变对象进行copy操作，是指针复制，mutableCopy操作是内容复制；
  对可变对象进行copy和mutableCopy都是内容复制。用代码简单表示如下：
    NSString *str = @&quot;hello word!&quot;;
    NSString *strCopy = [str copy] // 指针复制，strCopy与str的地址一样
    NSMutableString *strMCopy = [str mutableCopy] // 内容复制，strMCopy与str的地址不一样

    NSMutableString *mutableStr = [NSMutableString stringWithString: @&quot;hello word!&quot;];
    NSString *strCopy = [mutableStr copy] // 内容复制
    NSMutableString *strMCopy = [mutableStr mutableCopy] // 内容复制

二、集合类对象的copy与mutableCopy (同上)
  在集合类对象中，对不可变对象进行copy操作，是指针复制，mutableCopy操作是内容复制；
  对可变对象进行copy和mutableCopy都是内容复制。但是：集合对象的内容复制仅限于对象本身，对集合内的对象元素仍然是指针复制。(即单层内容复制)
    NSArray *arr = @[@[@&quot;a&quot;, @&quot;b&quot;], @[@&quot;c&quot;, @&quot;d&quot;];
    NSArray *copyArr = [arr copy]; // 指针复制
    NSMutableArray *mCopyArr = [arr mutableCopy]; //单层内容复制

    NSMutableArray *array = [NSMutableArray arrayWithObjects:[NSMutableString stringWithString:@&quot;a&quot;],@&quot;b&quot;,@&quot;c&quot;,nil];
    NSArray *copyArr = [mutableArr copy]; // 单层内容复制
    NSMutableArray *mCopyArr = [mutableArr mutableCopy]; // 单层内容复制

【总结一句话】：
    只有对不可变对象进行copy操作是指针复制（浅复制），其它情况都是内容复制（深复制）！
</code></pre>
</li>
<li><p><strong>这个写法会出什么问题：@property (nonatomic, copy) NSMutableArray *arr;</strong></p>
<pre><code class="objective-c">问题：添加,删除,修改数组内的元素的时候,程序会因为找不到对应的方法而崩溃。
//如：-[__NSArrayI removeObjectAtIndex:]: unrecognized selector sent to instance 0x7fcd1bc30460
// copy后返回的是不可变对象（即 arr 是 NSArray 类型，NSArray 类型对象不能调用 NSMutableArray 类型对象的方法）
原因：是因为 copy 就是复制一个不可变 NSArray 的对象，不能对 NSArray 对象进行添加/修改。
</code></pre>
</li>
<li><p><strong>如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？</strong></p>
<pre><code class="objective-c">若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 NSCopying 与 NSMutableCopying 协议。
具体步骤：
    1. 需声明该类遵从 NSCopying 协议
    2. 实现 NSCopying 协议的方法。
        // 该协议只有一个方法: 
        - (id)copyWithZone:(NSZone *)zone;
        // 注意：使用 copy 修饰符，调用的是copy方法，其实真正需要实现的是 “copyWithZone” 方法。
</code></pre>
</li>
<li><p><strong>写一个 setter 方法用于完成 @property (nonatomic, retain) NSString *name，写一个 setter 方法用于完成 @property (nonatomic, copy) NSString *name</strong></p>
<pre><code class="objective-c">答：
// retain
- (void)setName:(NSString *)str {
  [str retain];
  [_name release];
  _name = str;
}
// copy
- (void)setName:(NSString *)str {
  id t = [str copy];
  [_name release];
  _name = t;
}
</code></pre>
</li>
<li><p><strong>@synthesize 和 @dynamic 分别有什么作用？</strong></p>
<pre><code class="objective-c">@property有两个对应的词，一个是@synthesize（合成实例变量），一个是@dynamic。
如果@synthesize和@dynamic都没有写，那么默认的就是 @synthesize var = _var;
// 在类的实现代码里通过 @synthesize 语法可以来指定实例变量的名字。(@synthesize var = _newVar;)
1. @synthesize 的语义是如果你没有手动实现setter方法和getter方法，那么编译器会自动为你加上这两个方法。
2. @dynamic 告诉编译器，属性的setter与getter方法由用户自己实现，不自动生成（如，@dynamic var）。
</code></pre>
</li>
<li><p><strong>常见的 Objective-C 的数据类型有那些，和C的基本数据类型有什么区别？如：NSInteger和int</strong></p>
<pre><code>答：
Objective-C的数据类型有NSString，NSNumber，NSArray，NSMutableArray，NSData等等，这些都是class，创建后便是对象，而C语言的基本数据类型int，只是一定字节的内存空间，用于存放数值;NSInteger是基本数据类型，并不是NSNumber的子类，当然也不是NSObject的子类。NSInteger是基本数据类型Int或者Long的别名(NSInteger的定义typedef long NSInteger)，它的区别在于，NSInteger会根据系统是32位还是64位来决定是本身是int还是long。
</code></pre></li>
<li><p><strong>id 声明的对象有什么特性？</strong></p>
<pre><code>答：id 声明的对象具有运行时的特性，即可以指向任意类型的Objcetive-C的对象。
</code></pre></li>
<li><p><strong>Objective-C 如何对内存管理的，说说你的看法和解决方法？</strong></p>
<pre><code>答：Objective-C的内存管理主要有三种方式ARC(自动内存计数)、手动内存计数、内存池。
1). 自动内存计数ARC：由Xcode自动在App编译阶段，在代码中添加内存管理代码。
2). 手动内存计数MRC：遵循内存谁申请、谁释放；谁添加，谁释放的原则。
3). 内存释放池Release Pool：把需要释放的内存统一放在一个池子中，当池子被抽干后(drain)，池子中所有的内存空间也被自动释放掉。内存池的释放操作分为自动和手动。自动释放受runloop机制影响。
</code></pre></li>
<li><p><strong>Objective-C 中创建线程的方法是什么？如果在主线程中执行代码，方法是什么？如果想延时执行代码、方法又是什么？</strong></p>
<pre><code>答：线程创建有三种方法：使用NSThread创建、使用GCD的dispatch、使用子类化的NSOperation,然后将其加入NSOperationQueue;在主线程执行代码，方法是performSelectorOnMainThread，如果想延时执行代码可以用performSelector:onThread:withObject:waitUntilDone:
</code></pre></li>
<li><p><strong>Category（类别）、 Extension（扩展）和继承的区别</strong></p>
<pre><code>区别：
1. 分类有名字，类扩展没有分类名字，是一种特殊的分类。
2. 分类只能扩展方法（属性仅仅是声明，并没真正实现），类扩展可以扩展属性、成员变量和方法。
3. 继承可以增加，修改或者删除方法，并且可以增加属性。
</code></pre></li>
<li><p><strong>我们说的OC是动态运行时语言是什么意思？</strong></p>
<pre><code>答：主要是将数据类型的确定由编译时，推迟到了运行时。简单来说, 运行时机制使我们直到运行时才去决定一个对象的类别,以及调用该类别对象指定方法。
</code></pre></li>
<li><p><strong>为什么我们常见的delegate属性都用是week而不是retain/strong？</strong></p>
<pre><code>答：是为了防止delegate两端产生不必要的循环引用。
@property (nonatomic, weak) id&lt;UITableViewDelegate&gt; delegate;
</code></pre></li>
<li><p><strong>什么时候用delete，什么时候用Notification？</strong></p>
<pre><code>Delegate(委托模式)：1对1的反向消息通知功能。
Notification(通知模式)：只想要把消息发送出去，告知某些状态的变化。但是并不关心谁想要知道这个。
</code></pre></li>
<li><p><strong>什么是 KVO 和 KVC？</strong></p>
<pre><code class="objective-c">1). KVC(Key-Value-Coding)：键值编码 是一种通过字符串间接访问对象的方式（即给属性赋值）
       举例说明：
       stu.name = @&quot;张三&quot; // 点语法给属性赋值
       [stu setValue:@&quot;张三&quot; forKey:@&quot;name&quot;]; // 通过字符串使用KVC方式给属性赋值
       stu1.nameLabel.text = @&quot;张三&quot;;
       [stu1 setValue:@&quot;张三&quot; forKey:@&quot;nameLabel.text&quot;]; // 跨层赋值
2). KVO(key-Value-Observing)：键值观察机制 他提供了观察某一属性变化的方法，极大的简化了代码。
     KVO只能被KVC触发，包括使用setValue:forKey:方法和点语法。
   // 通过下方方法为属性添加KVO观察
   - (void)addObserver:(NSObject *)observer
                     forKeyPath:(NSString *)keyPath
                     options:(NSKeyValueObservingOptions)options
                     context:(nullable void *)context;
   // 当被观察的属性发送变化时，会自动触发下方方法                   
   - (void)observeValueForKeyPath:(NSString *)keyPath
                              ofObject:(id)object
                                  change:(NSDictionary *)change
                                 context:(void *)context{}

KVC 和 KVO 的 keyPath 可以是属性、实例变量、成员变量。
</code></pre>
</li>
<li><p><strong>KVC的底层实现？</strong></p>
<pre><code>当一个对象调用setValue方法时，方法内部会做以下操作：
1). 检查是否存在相应的key的set方法，如果存在，就调用set方法。
2). 如果set方法不存在，就会查找与key相同名称并且带下划线的成员变量，如果有，则直接给成员变量属性赋值。
3). 如果没有找到_key，就会查找相同名称的属性key，如果有就直接赋值。
4). 如果还没有找到，则调用valueForUndefinedKey:和setValue:forUndefinedKey:方法。
这些方法的默认实现都是抛出异常，我们可以根据需要重写它们。
</code></pre></li>
<li><p><strong>KVO的底层实现？</strong></p>
<pre><code>KVO基于runtime机制实现。
</code></pre></li>
<li><p><strong>ViewController生命周期</strong></p>
<pre><code>按照执行顺序排列：
1. initWithCoder：通过nib文件初始化时触发。
2. awakeFromNib：nib文件被加载的时候，会发生一个awakeFromNib的消息到nib文件中的每个对象。      
3. loadView：开始加载视图控制器自带的view。
4. viewDidLoad：视图控制器的view被加载完成。  
5. viewWillAppear：视图控制器的view将要显示在window上。
6. updateViewConstraints：视图控制器的view开始更新AutoLayout约束。
7. viewWillLayoutSubviews：视图控制器的view将要更新内容视图的位置。
8. viewDidLayoutSubviews：视图控制器的view已经更新视图的位置。
9. viewDidAppear：视图控制器的view已经展示到window上。 
10. viewWillDisappear：视图控制器的view将要从window上消失。
11. viewDidDisappear：视图控制器的view已经从window上消失。
</code></pre></li>
<li><p><strong>方法和选择器有何不同？</strong></p>
<pre><code>selector是一个方法的名字，方法是一个组合体，包含了名字和实现。
</code></pre></li>
<li><p><strong>你是否接触过OC中的反射机制？简单聊一下概念和使用</strong></p>
<pre><code>1). class反射
    通过类名的字符串形式实例化对象。
        Class class = NSClassFromString(@&quot;student&quot;); 
        Student *stu = [[class alloc] init];
    将类名变为字符串。
        Class class =[Student class];
        NSString *className = NSStringFromClass(class);
2). SEL的反射
    通过方法的字符串形式实例化方法。
        SEL selector = NSSelectorFromString(@&quot;setName&quot;);  
        [stu performSelector:selector withObject:@&quot;Mike&quot;];
    将方法变成字符串。
        NSStringFromSelector(@selector*(setName:));

</code></pre></li>
<li><p><strong>调用方法有两种方式：</strong></p>
<pre><code>1). 直接通过方法名来调用。[person show];
2). 间接的通过SEL数据来调用 SEL aaa = @selector(show); [person performSelector:aaa];  

</code></pre></li>
<li><p><strong>如何对iOS设备进行性能测试？</strong></p>
<pre><code class="objective-c">答： Profile-&gt; Instruments -&gt;Time Profiler
</code></pre>
</li>
<li><p><strong>开发项目时你是怎么检查内存泄露？</strong></p>
<pre><code>1). 静态分析 analyze。
2). instruments工具里面有个leak可以动态分析。

</code></pre></li>
<li><p><strong>什么是懒加载？</strong></p>
<pre><code>答：懒加载就是只在用到的时候才去初始化。也可以理解成延时加载。
我觉得最好也最简单的一个例子就是tableView中图片的加载显示了, 一个延时加载, 避免内存过高,一个异步加载,避免线程堵塞提高用户体验。

</code></pre></li>
<li><p><strong>类变量的 @public，@protected，@private，@package 声明各有什么含义？</strong></p>
<pre><code>@public 任何地方都能访问;
@protected 该类和子类中访问,是默认的;
@private 只能在本类中访问;
@package 本包内使用,跨包不可以。

</code></pre></li>
<li><p><strong>什么是谓词？</strong></p>
<pre><code class="objective-c">谓词就是通过NSPredicate给定的逻辑条件作为约束条件,完成对数据的筛选。
//定义谓词对象,谓词对象中包含了过滤条件(过滤条件比较多)
NSPredicate *predicate = [NSPredicate predicateWithFormat:@&quot;age&lt;%d&quot;,30];
//使用谓词条件过滤数组中的元素,过滤之后返回查询的结果
NSArray *array = [persons filteredArrayUsingPredicate:predicate];
</code></pre>
</li>
<li><p><strong>isa指针问题</strong></p>
<pre><code>isa：是一个Class 类型的指针. 每个实例对象有个isa的指针,他指向对象的类,而Class里也有个isa的指针, 指向meteClass(元类)。元类保存了类方法的列表。当类方法被调 用时,先会从本身查找类方法的实现,如果没有,元类会向他父类查找该方法。同时注意的是:元类(meteClass)也是类,它也是对象。元类也有isa指针,它的isa指针最终指向的是一个根元类(root meteClass)。根元类的isa指针指向本身,这样形成了一个封闭的内循环。

</code></pre></li>
<li><p><strong>如何访问并修改一个类的私有属性？</strong></p>
<pre><code>1). 一种是通过KVC获取。
2). 通过runtime访问并修改私有属性。

</code></pre></li>
<li><p><strong>一个objc对象的isa的指针指向什么？有什么作用？</strong></p>
<pre><code>答：指向他的类对象,从而可以找到对象上的方法。

</code></pre></li>
<li><p><strong>下面的代码输出什么？</strong></p>
<pre><code class="objective-c">@implementation Son : Father
- (id)init {
   if (self = [super init]) {
       NSLog(@&quot;%@&quot;, NSStringFromClass([self class])); // Son
       NSLog(@&quot;%@&quot;, NSStringFromClass([super class])); // Son
   }
   return self;
}
@end
// 解析：
self 是类的隐藏参数，指向当前调用方法的这个类的实例。
super是一个Magic Keyword，它本质是一个编译器标示符，和self是指向的同一个消息接收者。
不同的是：super会告诉编译器，调用class这个方法时，要去父类的方法，而不是本类里的。
上面的例子不管调用[self class]还是[super class]，接受消息的对象都是当前 Son *obj 这个对象。
</code></pre>
</li>
<li><p><strong>写一个完整的代理，包括声明、实现</strong></p>
<pre><code class="objective-c">// 创建
@protocol MyDelagate
@required
-(void)eat:(NSString *)foodName; 
@optional
-(void)run;
@end

//  声明 .h
@interface person: NSObject&lt;MyDelagate&gt;

@end

//  实现 .m
@implementation person
- (void)eat:(NSString *)foodName { 
   NSLog(@&quot;吃:%@!&quot;, foodName);
} 
- (void)run {
   NSLog(@&quot;run!&quot;);
}

@end
</code></pre>
</li>
<li><p><strong>isKindOfClass、isMemberOfClass、selector作用分别是什么</strong></p>
<pre><code>isKindOfClass：作用是某个对象属于某个类型或者继承自某类型。
isMemberOfClass：某个对象确切属于某个类型。
selector：通过方法名，获取在内存中的函数的入口地址。

</code></pre></li>
<li><p><strong>delegate 和 notification 的区别</strong></p>
<pre><code>1). 二者都用于传递消息，不同之处主要在于一个是一对一的，另一个是一对多的。
2). notification通过维护一个array，实现一对多消息的转发。
3). delegate需要两者之间必须建立联系，不然没法调用代理的方法；notification不需要两者之间有联系。

</code></pre></li>
<li><p><strong>什么是block？</strong></p>
<pre><code>闭包（block）：闭包就是获取其它函数局部变量的匿名函数。

</code></pre></li>
<li><p><strong>block反向传值</strong></p>
<pre><code class="objective-c">// 在控制器间传值可以使用代理或者block，使用block相对来说简洁。
// 在前一个控制器的touchesBegan:方法内实现如下代码。

// OneViewController.m
  TwoViewController *twoVC = [[TwoViewController alloc] init];
  twoVC.valueBlcok = ^(NSString *str) {
      NSLog(@&quot;OneViewController拿到值：%@&quot;, str); 
  };
  [self presentViewController:twoVC animated:YES completion:nil];

  // TwoViewController.h   （在.h文件中声明一个block属性）
  @property (nonatomic ,strong) void(^valueBlcok)(NSString *str);

  // TwoViewController.m   （在.m文件中实现方法）
- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event {
    // 传值:调用block
    if (_valueBlcok) {
        _valueBlcok(@&quot;123456&quot;);
    }
}
</code></pre>
</li>
<li><p><strong>block的注意点</strong></p>
<pre><code>1). 在block内部使用外部指针且会造成循环引用情况下，需要用__week修饰外部指针：
    __weak typeof(self) weakSelf = self; 
2). 在block内部如果调用了延时函数还使用弱指针会取不到该指针，因为已经被销毁了，需要在block内部再将弱指针重新强引用一下。
    __strong typeof(self) strongSelf = weakSelf;
3). 如果需要在block内部改变外部栈区变量的话，需要在用__block修饰外部变量。
</code></pre></li>
<li><p><strong>BAD_ACCESS在什么情况下出现？</strong></p>
<pre><code>答：这种问题在开发时经常遇到。原因是访问了野指针，比如访问已经释放对象的成员变量或者发消息、死循环等。
</code></pre></li>
<li><p><strong>lldb（gdb）常用的控制台调试命令？</strong></p>
<pre><code>1). p 输出基本类型。是打印命令，需要指定类型。是print的简写
    p (int)[[[self view] subviews] count]
2). po 打印对象，会调用对象description方法。是print-object的简写
    po [self view]
3). expr 可以在调试时动态执行指定表达式，并将结果打印出来。常用于在调试过程中修改变量的值。
4). bt：打印调用堆栈，是thread backtrace的简写，加all可打印所有thread的堆栈
5). br l：是breakpoint list的简写
</code></pre></li>
<li><p><strong>你一般是怎么用Instruments的？</strong></p>
<pre><code>Instruments里面工具很多，常用：
1). Time Profiler: 性能分析
2). Zombies：检查是否访问了僵尸对象，但是这个工具只能从上往下检查，不智能。
3). Allocations：用来检查内存，写算法的那批人也用这个来检查。
4). Leaks：检查内存，看是否有内存泄露。
</code></pre></li>
<li><p><strong>iOS中常用的数据存储方式有哪些？</strong></p>
<pre><code>数据存储有四种方案：NSUserDefault、KeyChain、file、DB。
    其中File有三种方式：plist、Archive（归档）
    DB包括：SQLite、FMDB、CoreData
</code></pre></li>
<li><p><strong>iOS的沙盒目录结构是怎样的？</strong></p>
<pre><code>沙盒结构：
1). Application：存放程序源文件，上架前经过数字签名，上架后不可修改。
2). Documents：常用目录，iCloud备份目录，存放数据。（这里不能存缓存文件，否则上架不被通过）
3). Library：
        Caches：存放体积大又不需要备份的数据。(常用的缓存路径)
        Preference：设置目录，iCloud会备份设置信息。
4). tmp：存放临时文件，不会被备份，而且这个文件下的数据有可能随时被清除的可能。
</code></pre></li>
<li><p><strong>iOS多线程技术有哪几种方式？</strong></p>
<pre><code>答：pthread、NSThread、GCD、NSOperation
</code></pre></li>
<li><p><strong>GCD 与 NSOperation 的区别：</strong></p>
<pre><code>GCD 和 NSOperation 都是用于实现多线程：
    GCD 基于C语言的底层API，GCD主要与block结合使用，代码简洁高效。
    NSOperation 属于Objective-C类，是基于GCD更高一层的封装。复杂任务一般用NSOperation实现。
</code></pre></li>
<li><p><strong>写出使用GCD方式从子线程回到主线程的方法代码</strong></p>
<pre><code class="objective-c">答：dispatch_sync(dispatch_get_main_queue(), ^{ });
</code></pre>
</li>
<li><p><strong>如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）</strong></p>
<pre><code class="objective-c">// 使用Dispatch Group追加block到Global Group Queue,这些block如果全部执行完毕，就会执行Main Dispatch Queue中的结束处理的block。
// 创建队列组
dispatch_group_t group = dispatch_group_create();
// 获取全局并发队列
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_group_async(group, queue, ^{ /*加载图片1 */ });
dispatch_group_async(group, queue, ^{ /*加载图片2 */ });
dispatch_group_async(group, queue, ^{ /*加载图片3 */ }); 
// 当并发队列组中的任务执行完毕后才会执行这里的代码
dispatch_group_notify(group, dispatch_get_main_queue(), ^{
        // 合并图片
});
</code></pre>
</li>
<li><p><strong>dispatch_barrier_async（栅栏函数）的作用是什么？</strong></p>
<pre><code class="objective-c">函数定义：dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block);
作用：
    1.在它前面的任务执行结束后它才执行，它后面的任务要等它执行完成后才会开始执行。
    2.避免数据竞争

// 1.创建并发队列
dispatch_queue_t queue = dispatch_queue_create(&quot;myQueue&quot;, DISPATCH_QUEUE_CONCURRENT);
// 2.向队列中添加任务
dispatch_async(queue, ^{  // 1.2是并行的
    NSLog(@&quot;任务1, %@&quot;,[NSThread currentThread]);
});
dispatch_async(queue, ^{
    NSLog(@&quot;任务2, %@&quot;,[NSThread currentThread]);
});

dispatch_barrier_async(queue, ^{
    NSLog(@&quot;任务 barrier, %@&quot;, [NSThread currentThread]);
});

dispatch_async(queue, ^{   // 这两个是同时执行的
    NSLog(@&quot;任务3, %@&quot;,[NSThread currentThread]);
});
dispatch_async(queue, ^{
    NSLog(@&quot;任务4, %@&quot;,[NSThread currentThread]);
});

// 输出结果: 任务1 任务2 ——》 任务 barrier ——》任务3 任务4 
// 其中的任务1与任务2，任务3与任务4 由于是并行处理先后顺序不定。
</code></pre>
</li>
<li><p><strong>以下代码运行结果如何？</strong></p>
<pre><code class="objective-c">- (void)viewDidLoad {
    [super viewDidLoad];
    NSLog(@&quot;1&quot;);
    dispatch_sync(dispatch_get_main_queue(), ^{
        NSLog(@&quot;2&quot;);
    });
    NSLog(@&quot;3&quot;);
}
// 只输出：1。（主线程死锁）
</code></pre>
</li>
<li><p><strong>什么是 RunLoop</strong></p>
<pre><code class="objective-c">从字面上讲就是运行循环，它内部就是do-while循环，在这个循环内部不断地处理各种任务。
一个线程对应一个RunLoop，基本作用就是保持程序的持续运行，处理app中的各种事件。通过runloop，有事运行，没事就休息，可以节省cpu资源，提高程序性能。

主线程的run loop默认是启动的。iOS的应用程序里面，程序启动后会有一个如下的main()函数
int main(int argc, char * argv[]) {
    @autoreleasepool {
        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
    }
}
</code></pre>
</li>
<li><p><strong>什么是 Runtime</strong></p>
<pre><code>Runtime又叫运行时，是一套底层的C语言API，其为iOS内部的核心之一，我们平时编写的OC代码，底层都是基于它来实现的。
</code></pre></li>
<li><p><strong>Runtime实现的机制是什么，怎么用，一般用于干嘛？</strong></p>
<pre><code class="objective-c">1). 使用时需要导入的头文件 &lt;objc/message.h&gt; &lt;objc/runtime.h&gt;
2). Runtime 运行时机制，它是一套C语言库。
3). 实际上我们编写的所有OC代码，最终都是转成了runtime库的东西。
    比如：
        类转成了 Runtime 库里面的结构体等数据类型，
        方法转成了 Runtime 库里面的C语言函数，
        平时调方法都是转成了 objc_msgSend 函数（所以说OC有个消息发送机制）
    // OC是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。
    // [stu show];  在objc动态编译时，会被转意为：objc_msgSend(stu, @selector(show));    
4). 因此，可以说 Runtime 是OC的底层实现，是OC的幕后执行者。

有了Runtime库，能做什么事情呢？
 Runtime库里面包含了跟类、成员变量、方法相关的API。
 比如：
    （1）获取类里面的所有成员变量。
    （2）为类动态添加成员变量。
    （3）动态改变类的方法实现。
    （4）为类动态添加新的方法等。
 因此，有了Runtime，想怎么改就怎么改。
</code></pre>
</li>
<li><p><strong>什么是 Method Swizzle（黑魔法），什么情况下会使用？</strong></p>
<pre><code>1). 在没有一个类的实现源码的情况下，想改变其中一个方法的实现，除了继承它重写、和借助类别重名方法暴力抢先之外，还有更加灵活的方法 Method Swizzle。
2). Method Swizzle 指的是改变一个已存在的选择器对应的实现的过程。OC中方法的调用能够在运行时通过改变，通过改变类的调度表中选择器到最终函数间的映射关系。
3). 在OC中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。利用OC的动态特性，可以实现在运行时偷换selector对应的方法实现。
4). 每个类都有一个方法列表，存放着selector的名字和方法实现的映射关系。IMP有点类似函数指针，指向具体的方法实现。
5). 我们可以利用 method_exchangeImplementations 来交换2个方法中的IMP。
6). 我们可以利用 class_replaceMethod 来修改类。
7). 我们可以利用 method_setImplementation 来直接设置某个方法的IMP。
8). 归根结底，都是偷换了selector的IMP。
</code></pre></li>
<li><p><strong>_objc_msgForward 函数是做什么的，直接调用它将会发生什么？</strong></p>
<pre><code>答：_objc_msgForward是 IMP 类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，_objc_msgForward会尝试做消息转发。
</code></pre></li>
<li><p><strong>什么是 TCP / UDP ?</strong></p>
<pre><code>TCP：传输控制协议。
UDP：用户数据协议。

TCP 是面向连接的，建立连接需要经历三次握手，是可靠的传输层协议。
UDP 是面向无连接的，数据传输是不可靠的，它只管发，不管收不收得到。
简单的说，TCP注重数据安全，而UDP数据传输快点，但安全性一般。
</code></pre></li>
<li><p><strong>通信底层原理（OSI七层模型）</strong></p>
<pre><code>OSI采用了分层的结构化技术，共分七层：
    物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。
</code></pre></li>
<li><p><strong>介绍一下XMPP？</strong></p>
<pre><code>XMPP是一种以XML为基础的开放式实时通信协议。
简单的说，XMPP就是一种协议，一种规定。就是说，在网络上传东西，XMM就是规定你上传大小的格式。
</code></pre></li>
<li><p><strong>OC中创建线程的方法是什么？如果在主线程中执行代码，方法是什么？</strong></p>
<pre><code class="objective-c">// 创建线程的方法
- [NSThread detachNewThreadSelector:nil toTarget:nil withObject:nil]
- [self performSelectorInBackground:nil withObject:nil];
- [[NSThread alloc] initWithTarget:nil selector:nil object:nil];
- dispatch_async(dispatch_get_global_queue(0, 0), ^{});
- [[NSOperationQueue new] addOperation:nil];

// 主线程中执行代码的方法
- [self performSelectorOnMainThread:nil withObject:nil waitUntilDone:YES];
- dispatch_async(dispatch_get_main_queue(), ^{});
- [[NSOperationQueue mainQueue] addOperation:nil];
</code></pre>
</li>
<li><p><strong>tableView的重用机制？</strong></p>
<pre><code>答：UITableView 通过重用单元格来达到节省内存的目的: 通过为每个单元格指定一个重用标识符，即指定了单元格的种类,当屏幕上的单元格滑出屏幕时，系统会把这个单元格添加到重用队列中，等待被重用，当有新单元格从屏幕外滑入屏幕内时，从重用队列中找看有没有可以重用的单元格，如果有，就拿过来用，如果没有就创建一个来使用。
</code></pre></li>
<li><p><strong>用伪代码写一个线程安全的单例模式</strong></p>
<pre><code class="objective-c">static id _instance;
+ (id)allocWithZone:(struct _NSZone *)zone {
   static dispatch_once_t onceToken;
   dispatch_once(&amp;onceToken, ^{
       _instance = [super allocWithZone:zone];
   });
   return _instance;
}

+ (instancetype)sharedData {
   static dispatch_once_t onceToken;
   dispatch_once(&amp;onceToken, ^{
       _instance = [[self alloc] init];
   });
   return _instance;
}

- (id)copyWithZone:(NSZone *)zone {
   return _instance;
}
</code></pre>
</li>
<li><p><strong>如何实现视图的变形?</strong></p>
<pre><code>答：通过修改view的 transform 属性即可。
</code></pre></li>
<li><p><strong>在手势对象基础类UIGestureRecognizer的常用子类手势类型中哪两个手势发生后，响应只会执行一次？</strong></p>
<pre><code>答：UITapGestureRecognizer,UISwipeGestureRecognizer是一次性手势,手势发生后,响应只会执行一次。
</code></pre></li>
<li><p><strong>字符串常用方法：</strong></p>
<pre><code class="objective-c">NSString *str = @&quot;abc*123&quot;;
NSArray *arr = [str componentsSeparatedByString:@&quot;*&quot;]; //以目标字符串把原字符串分割成两部分，存到数组中。@[@&quot;abc&quot;, @&quot;123&quot;];
</code></pre>
</li>
<li><p><strong>如何高性能的给 UIImageView 加个圆角?</strong></p>
<pre><code class="objective-c">// 1. 不好的解决方案：使用下面的方式会强制Core Animation提前渲染屏幕的离屏绘制, 而离屏绘制就会给性能带来负面影响，会有卡顿的现象出现。
self.view.layer.cornerRadius = 5.0f;
self.view.layer.masksToBounds = YES;

// 2. 正确的解决方案：使用绘图技术
- (UIImage *)circleImage {
    // NO代表透明
    UIGraphicsBeginImageContextWithOptions(self.size, NO, 0.0);
    // 获得上下文
    CGContextRef ctx = UIGraphicsGetCurrentContext();
    // 添加一个圆
    CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height);
    CGContextAddEllipseInRect(ctx, rect);
    // 裁剪
    CGContextClip(ctx);
    // 将图片画上去
    [self drawInRect:rect];
    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
    // 关闭上下文
    UIGraphicsEndImageContext();
    return image;
}

// 3. 还有一种方案：使用了贝塞尔曲线&quot;切割&quot;个这个图片, 给UIImageView 添加了的圆角，其实也是通过绘图技术来实现的。
UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];
imageView.center = CGPointMake(200, 300);
UIImage *anotherImage = [UIImage imageNamed:@&quot;image&quot;];
UIGraphicsBeginImageContextWithOptions(imageView.bounds.size, NO, 1.0);
[[UIBezierPath bezierPathWithRoundedRect:imageView.bounds
                       cornerRadius:50] addClip];
[anotherImage drawInRect:imageView.bounds];
imageView.image = UIGraphicsGetImageFromCurrentImageContext();
UIGraphicsEndImageContext();
[self.view addSubview:imageView];
</code></pre>
</li>
<li><p><strong>你是怎么封装一个view的</strong></p>
<pre><code class="objective-c">1. 可以通过纯代码或者xib的方式来封装子控件
2. 建立一个跟view相关的模型，然后将模型数据传给view，通过模型上的数据给view的子控件赋值

/**
 *  纯代码初始化控件时一定会走这个方法
 */
- (instancetype)initWithFrame:(CGRect)frame {
    if(self = [super initWithFrame:frame]) {
        [self setupUI];
    }
    return self;
}

/**
 *  通过xib初始化控件时一定会走这个方法
 */
- (id)initWithCoder:(NSCoder *)aDecoder {
    if(self = [super initWithCoder:aDecoder]) {
        [self setupUI];
    }
    return self;
}

- (void)setupUI {
    // 初始化代码
}
</code></pre>
</li>
<li><p><strong>HTTP协议中 POST 方法和 GET 方法有那些区别?</strong></p>
<pre><code>1. GET用于向服务器请求数据，POST用于提交数据
2. GET请求，请求参数拼接形式暴露在地址栏，而POST请求参数则放在请求体里面，因此GET请求不适合用于验证密码等操作
3. GET请求的URL有长度限制，POST请求不会有长度限制
</code></pre></li>
<li><p><strong>请简单的介绍下APNS发送系统消息的机制</strong></p>
<pre><code>APNS优势：杜绝了类似安卓那种为了接受通知不停在后台唤醒程序保持长连接的行为，由iOS系统和APNS进行长连接替代。
APNS的原理：
    1). 应用在通知中心注册，由iOS系统向APNS请求返回设备令牌(device Token)
    2). 应用程序接收到设备令牌并发送给自己的后台服务器
    3). 服务器把要推送的内容和设备发送给APNS
    4). APNS根据设备令牌找到设备，再由iOS根据APPID把推送内容展示
</code></pre><p>​</p>
</li>
</ol>
<h1 id="第三方框架"><a href="#第三方框架" class="headerlink" title="第三方框架"></a>第三方框架</h1><ol>
<li><p><strong>AFNetworking 底层原理分析</strong></p>
<pre><code class="objective-c">AFNetworking主要是对NSURLSession和NSURLConnection(iOS9.0废弃)的封装,其中主要有以下类:
1). AFHTTPRequestOperationManager：内部封装的是 NSURLConnection, 负责发送网络请求, 使用最多的一个类。(3.0废弃)
2). AFHTTPSessionManager：内部封装是 NSURLSession, 负责发送网络请求,使用最多的一个类。
3). AFNetworkReachabilityManager：实时监测网络状态的工具类。当前的网络环境发生改变之后,这个工具类就可以检测到。
4). AFSecurityPolicy：网络安全的工具类, 主要是针对 HTTPS 服务。

5). AFURLRequestSerialization：序列化工具类,基类。上传的数据转换成JSON格式
    (AFJSONRequestSerializer).使用不多。
6). AFURLResponseSerialization：反序列化工具类;基类.使用比较多:
7). AFJSONResponseSerializer; JSON解析器,默认的解析器.
8). AFHTTPResponseSerializer; 万能解析器; JSON和XML之外的数据类型,直接返回二进
制数据.对服务器返回的数据不做任何处理.
9). AFXMLParserResponseSerializer; XML解析器;
</code></pre>
</li>
<li><p><strong>描述下SDWebImage里面给UIImageView加载图片的逻辑</strong></p>
<pre><code>SDWebImage 中为 UIImageView 提供了一个分类UIImageView+WebCache.h, 这个分类中有一个最常用的接口sd_setImageWithURL:placeholderImage:，会在真实图片出现前会先显示占位图片，当真实图片被加载出来后再替换占位图片。

加载图片的过程大致如下：
    1.首先会在 SDWebImageCache 中寻找图片是否有对应的缓存, 它会以url 作为数据的索引先在内存中寻找是否有对应的缓存
    2.如果缓存未找到就会利用通过MD5处理过的key来继续在磁盘中查询对应的数据, 如果找到了, 就会把磁盘中的数据加载到内存中，并将图片显示出来
    3.如果在内存和磁盘缓存中都没有找到，就会向远程服务器发送请求，开始下载图片
    4.下载后的图片会加入缓存中，并写入磁盘中
    5.整个获取图片的过程都是在子线程中执行，获取到图片后回到主线程将图片显示出来

SDWebImage原理：
调用类别的方法：
    1. 从内存（字典）中找图片（当这个图片在本次使用程序的过程中已经被加载过），找到直接使用。
    2. 从沙盒中找（当这个图片在之前使用程序的过程中被加载过），找到使用，缓存到内存中。
    3. 从网络上获取，使用，缓存到内存，缓存到沙盒。

</code></pre></li>
<li><p><strong>友盟统计接口统计的所有功能</strong></p>
<pre><code>APP启动速度，APP停留页面时间等
</code></pre></li>
</ol>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><ol>
<li><p><strong>不用中间变量,用两种方法交换A和B的值</strong></p>
<pre><code class="objective-c">// 1.中间变量
void swap(int a, int b) {
   int temp = a;
   a = b;
   b = temp;
}

// 2.加法
void swap(int a, int b) {
   a = a + b;
   b = a - b;
   a = a - b;
}

// 3.异或（相同为0，不同为1. 可以理解为不进位加法）
void swap(int a, int b) {
   a = a ^ b;
   b = a ^ b;
   a = a ^ b;
}
</code></pre>
</li>
<li><p><strong>求最大公约数</strong></p>
<pre><code class="c">/** 1.直接遍历法 */
int maxCommonDivisor(int a, int b) {
    int max = 0;
    for (int i = 1; i &lt;=b; i++) {
        if (a % i == 0 &amp;&amp; b % i == 0) {
            max = i;
        }
    }
    return max;
}
/** 2.辗转相除法 */
int maxCommonDivisor(int a, int b) {
    int r;
    while(a % b &gt; 0) {
        r = a % b;
        a = b;
        b = r;
    }
    return b;
}

// 扩展：最小公倍数 = (a * b)/最大公约数
</code></pre>
</li>
<li><p><strong>模拟栈操作</strong></p>
<pre><code class="c"> /**
 *  栈是一种数据结构，特点：先进后出
 *  练习：使用全局变量模拟栈的操作
 */
#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;assert.h&gt;
//保护全局变量：在全局变量前加static后，这个全局变量就只能在本文件中使用
static int data[1024];//栈最多能保存1024个数据
static int count = 0;//目前已经放了多少个数(相当于栈顶位置)

//数据入栈 push
void push(int x){
      assert(!full());//防止数组越界
    data[count++] = x;
}
//数据出栈 pop
int pop(){
    assert(!empty());
    return data[--count];
}
//查看栈顶元素 top
int top(){
    assert(!empty());
    return data[count-1];
}

//查询栈满 full
bool full() {
    if(count &gt;= 1024) {
         return 1;
    }
     return 0; 
}

//查询栈空 empty
bool empty() {
    if(count &lt;= 0) {
        return 1;
    }
    return 0;
}

int main(){
    //入栈
    for (int i = 1; i &lt;= 10; i++) {
        push(i);
    }

    //出栈
    while(!empty()){
        printf(&quot;%d &quot;, top()); //栈顶元素
        pop(); //出栈
    }
    printf(&quot;\n&quot;);

    return 0;
}
</code></pre>
</li>
<li><p><strong>排序算法</strong></p>
<p>选择排序、冒泡排序、插入排序三种排序算法可以总结为如下：</p>
<ul>
<li><p>都将数组分为已排序部分和未排序部分。</p>
<pre><code>1. 选择排序将已排序部分定义在左端，然后选择未排序部分的最小元素和未排序部分的第一个元素交换。
2. 冒泡排序将已排序部分定义在右端，在遍历未排序部分的过程执行交换，将最大元素交换到最右端。
3. 插入排序将已排序部分定义在左端，将未排序部分元的第一个元素插入到已排序部分合适的位置。

</code></pre></li>
<li><p>选择排序</p>
</li>
</ul>
<pre><code class="c">/** 
 *    【选择排序】：最值出现在起始端
 *    
 *    第1趟：在n个数中找到最小(大)数与第一个数交换位置
 *    第2趟：在剩下n-1个数中找到最小(大)数与第二个数交换位置
 *    重复这样的操作...依次与第三个、第四个...数交换位置
 *    第n-1趟，最终可实现数据的升序（降序）排列。
 *
 */
void selectSort(int *arr, int length) {
    for (int i = 0; i &lt; length - 1; i++) { //趟数
        for (int j = i + 1; j &lt; length; j++) { //比较次数
            if (arr[i] &gt; arr[j]) {
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
    }
}
</code></pre>
<ul>
<li>冒泡排序</li>
</ul>
<pre><code class="c">/** 
 *    【冒泡排序】：相邻元素两两比较，比较完一趟，最值出现在末尾
 *    第1趟：依次比较相邻的两个数，不断交换（小数放前，大数放后）逐个推进，最值最后出现在第n个元素位置
 *    第2趟：依次比较相邻的两个数，不断交换（小数放前，大数放后）逐个推进，最值最后出现在第n-1个元素位置
 *     ……   ……
 *    第n-1趟：依次比较相邻的两个数，不断交换（小数放前，大数放后）逐个推进，最值最后出现在第2个元素位置    
 */
void bublleSort(int *arr, int length) {
    for(int i = 0; i &lt; length - 1; i++) { //趟数
        for(int j = 0; j &lt; length - i - 1; j++) { //比较次数
            if(arr[j] &gt; arr[j+1]) {
                int temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        } 
    }
}
</code></pre>
</li>
<li><p><strong>折半查找（二分查找）</strong></p>
<pre><code class="c">/**
 *    折半查找：优化查找时间（不用遍历全部数据）
 *
 *    折半查找的原理：
 *   1&gt; 数组必须是有序的
 *   2&gt; 必须已知min和max（知道范围）
 *   3&gt; 动态计算mid的值，取出mid对应的值进行比较
 *   4&gt; 如果mid对应的值大于要查找的值，那么max要变小为mid-1
 *   5&gt; 如果mid对应的值小于要查找的值，那么min要变大为mid+1
 *
 */ 

// 已知一个有序数组, 和一个key, 要求从数组中找到key对应的索引位置 
int findKey(int *arr, int length, int key) {
    int min = 0, max = length - 1, mid;
    while (min &lt;= max) {
        mid = (min + max) / 2; //计算中间值
        if (key &gt; arr[mid]) {
            min = mid + 1;
        } else if (key &lt; arr[mid]) {
            max = mid - 1;
        } else {
            return mid;
        }
    }
    return -1;
}
</code></pre>
<p>​</p>
</li>
</ol>
<p><strong>编码格式（优化细节）</strong></p>
<ol>
<li><p>在 Objective-C 中，enum 建议使用 <code>NS_ENUM</code> 和 <code>NS_OPTIONS</code> 宏来定义枚举类型。</p>
<pre><code class="objective-c">//定义一个枚举(比较严密)
typedef NS_ENUM(NSInteger, BRUserGender) {
    BRUserGenderUnknown,    // 未知
    BRUserGenderMale,        // 男性
    BRUserGenderFemale,        // 女性
    BRUserGenderNeuter        // 无性
};
</code></pre>
<pre><code class="objective-c">@interface BRUser : NSObject&lt;NSCopying&gt;

@property (nonatomic, readonly, copy) NSString *name;
@property (nonatomic, readonly, assign) NSUInteger age;
@property (nonatomic, readonly, assign) BRUserGender gender;

- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age gender:(BRUserGender)gender;

@end

// 说明：
// 既然该类中已经有一个“初始化方法” ，用于设置 name、age 和 gender 的初始值: 那么在设计对应 @property 时就应该尽量使用不可变的对象：其三个属性都应该设为“只读”。用初始化方法设置好属性值之后，就不能再改变了。
// 属性的参数应该按照下面的顺序排列： （原子性，读写，内存管理）
</code></pre>
</li>
<li><p>避免使用C语言中的基本数据类型，建议使用 Foundation 数据类型，对应关系如下：</p>
<pre><code class="objective-c">int -&gt; NSInteger
unsigned -&gt; NSUInteger
float -&gt; CGFloat
动画时间 -&gt; NSTimeInterval
</code></pre>
<p>​</p>
</li>
</ol>
<h1 id="其它知识点"><a href="#其它知识点" class="headerlink" title="其它知识点"></a>其它知识点</h1><ol>
<li><p><strong>HomeKit</strong>，是苹果2014年发布的智能家居平台。</p>
</li>
<li><p><strong>什么是 OpenGL、Quartz 2D？</strong></p>
<pre><code>Quatarz 2d 是Apple提供的基本图形工具库。只是适用于2D图形的绘制。
OpenGL，是一个跨平台的图形开发库。适用于2D和3D图形的绘制。

</code></pre></li>
<li><p><strong>ffmpeg框架：</strong></p>
<p>ffmpeg 是音视频处理工具，既有音视频编码解码功能，又可以作为播放器使用。 </p>
</li>
</ol>
<ol start="4">
<li><p><strong>谈谈 UITableView 的优化</strong></p>
<pre><code>1). 正确的复用cell。
2). 设计统一规格的Cell
3). 提前计算并缓存好高度（布局），因为heightForRowAtIndexPath:是调用最频繁的方法；
4). 异步绘制，遇到复杂界面，遇到性能瓶颈时，可能就是突破口；
4). 滑动时按需加载，这个在大量图片展示，网络加载的时候很管用！
5). 减少子视图的层级关系
6). 尽量使所有的视图不透明化以及做切圆操作。
7). 不要动态的add 或者 remove 子控件。最好在初始化时就添加完，然后通过hidden来控制是否显示。
8). 使用调试工具分析问题。
</code></pre></li>
<li><p><strong>如何实行cell的动态的行高</strong></p>
<pre><code>如果希望每条数据显示自身的行高，必须设置两个属性，1.预估行高，2.自定义行高。
设置预估行高 tableView.estimatedRowHeight = 200。
设置定义行高 tableView.estimatedRowHeight = UITableViewAutomaticDimension。 
如果要让自定义行高有效，必须让容器视图有一个自下而上的约束。
</code></pre></li>
<li><p><strong>说说你对 block 的理解</strong></p>
<pre><code>栈上的自动复制到堆上，block 的属性修饰符是 copy，循环引用的原理和解决方案。
</code></pre></li>
<li><p><strong>说说你对 runtime 的理解</strong></p>
<pre><code>主要是方法调用时如何查找缓存，如何找到方法，找不到方法时怎么转发，对象的内存布局。
</code></pre></li>
<li><p><strong>什么是野指针、空指针？</strong></p>
<pre><code>野指针：不知道指向了哪里的指针叫野指针。即指针指向不确定，指针存的地址是一个垃圾值，未初始化。
空指针：不指向任何位置的指针叫空指针。即指针没有指向，指针存的地址是一个空地址，NULL。
</code></pre></li>
<li><p><strong>什么是 OOA / OOD / OOP ?</strong></p>
<pre><code>OOA（Object Oriented Analysis）   --面向对象分析
OOD（Object Oriented Design）     --面向对象设计
OOP（Object Oriented Programming）--面向对象编程
</code></pre></li>
</ol>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS开发中常用知识点总结</title>
    <url>/p/20171105-ios-core-knowledge-summary.html</url>
    <content><![CDATA[<h1 id="1-设置滑动的时候隐藏navigationBar"><a href="#1-设置滑动的时候隐藏navigationBar" class="headerlink" title="1.设置滑动的时候隐藏navigationBar"></a>1.设置滑动的时候隐藏navigationBar</h1><pre><code class="objective-c">self.navigationController.hidesBarsOnSwipe = Yes;
</code></pre>
<h1 id="2-获取UIWebView的高度"><a href="#2-获取UIWebView的高度" class="headerlink" title="2.获取UIWebView的高度"></a>2.获取UIWebView的高度</h1><pre><code class="objective-c">- (void)webViewDidFinishLoad:(UIWebView *)webView  {  
    CGFloat height = [[webView stringByEvaluatingJavaScriptFromString:@&quot;document.body.offsetHeight&quot;] floatValue];  
    CGRect frame = webView.frame;
    webView.frame = CGRectMake(frame.origin.x, frame.origin.y, frame.size.width, height);  
}
</code></pre>
<h1 id="3-带有中文的URL处理"><a href="#3-带有中文的URL处理" class="headerlink" title="3.带有中文的URL处理"></a>3.带有中文的URL处理</h1><pre><code class="objective-c">// 如：http://static.tripbe.com/videofiles/视频/我的视频.mp4
NSString *path  = (__bridge_transfer NSString *)CFURLCreateStringByReplacingPercentEscapesUsingEncoding(NULL, (__bridge CFStringRef)model.mp4_url, CFSTR(&quot;&quot;), CFStringConvertNSStringEncodingToEncoding(NSUTF8StringEncoding));
</code></pre>
<h1 id="4-调用代码使APP进入后台，达到点击Home键的效果。（私有API）"><a href="#4-调用代码使APP进入后台，达到点击Home键的效果。（私有API）" class="headerlink" title="4.调用代码使APP进入后台，达到点击Home键的效果。（私有API）"></a>4.调用代码使APP进入后台，达到点击Home键的效果。（私有API）</h1><pre><code class="objective-c">[[UIApplication sharedApplication] performSelector:@selector(suspend)];
</code></pre>
<h1 id="5-给UIView设置图片（UILabel一样适用）"><a href="#5-给UIView设置图片（UILabel一样适用）" class="headerlink" title="5.给UIView设置图片（UILabel一样适用）"></a>5.给UIView设置图片（UILabel一样适用）</h1><ul>
<li>第一种方法： 利用的UIView的设置背景颜色方法，用图片做图案颜色，然后传给背景颜色。</li>
</ul>
<pre><code class="objective-c">UIColor *bgColor = [UIColor colorWithPatternImage: [UIImage imageNamed:@&quot;bgImg.png&quot;];
UIView *myView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 320, 480)];
[myView setBackGroundColor:bgColor];
</code></pre>
<ul>
<li>第二种方法：</li>
</ul>
<pre><code class="objective-c">UIImage *image = [UIImage imageNamed:@&quot;yourPicName@2x.png&quot;];
yourView.layer.contents = (__bridge id)image.CGImage;
//设置显示的图片范围
yourView.layer.contentsCenter = CGRectMake(0.25, 0.25, 0.5, 0.5); //四个值在0-1之间，对应的为x，y，width，height。
</code></pre>
<h1 id="6-去掉UITableView多余的分割线"><a href="#6-去掉UITableView多余的分割线" class="headerlink" title="6.去掉UITableView多余的分割线"></a>6.去掉UITableView多余的分割线</h1><pre><code class="objective-c">self.tableView.tableFooterView = [UIView new];
</code></pre>
<h1 id="7-调整cell分割线的位置，两个方法一起用"><a href="#7-调整cell分割线的位置，两个方法一起用" class="headerlink" title="7.调整cell分割线的位置，两个方法一起用"></a>7.调整cell分割线的位置，两个方法一起用</h1><pre><code class="objective-c">-(void)viewDidLayoutSubviews {

    if ([self.mytableview respondsToSelector:@selector(setSeparatorInset:)]) {
        [self.mytableview setSeparatorInset:UIEdgeInsetsMake(0, 0, 0, 0)];

    }
    if ([self.mytableview respondsToSelector:@selector(setLayoutMargins:)])  {
        [self.mytableview setLayoutMargins:UIEdgeInsetsMake(0, 0, 0, 0)];
    }

}

#pragma mark - cell分割线
- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath {
    if ([cell respondsToSelector:@selector(setSeparatorInset:)]){
        [cell setSeparatorInset:UIEdgeInsetsMake(0, 0, 0, 0)];
    }
    if ([cell respondsToSelector:@selector(setLayoutMargins:)]) {
        [cell setLayoutMargins:UIEdgeInsetsMake(0, 0, 0, 0)];
    }
}
</code></pre>
<h1 id="8-UISearchController和UISearchBar的Cancle按钮改title问题"><a href="#8-UISearchController和UISearchBar的Cancle按钮改title问题" class="headerlink" title="8.UISearchController和UISearchBar的Cancle按钮改title问题"></a>8.UISearchController和UISearchBar的Cancle按钮改title问题</h1><pre><code class="objective-c">- (BOOL)searchBarShouldBeginEditing:(UISearchBar *)searchBar {
    searchController.searchBar.showsCancelButton = YES;
    UIButton *canceLBtn = [searchController.searchBar valueForKey:@&quot;cancelButton&quot;];
    [canceLBtn setTitle:@&quot;取消&quot; forState:UIControlStateNormal];
    [canceLBtn setTitleColor:[UIColor colorWithRed:14.0/255.0 green:180.0/255.0 blue:0.0/255.0 alpha:1.00] forState:UIControlStateNormal];
    searchBar.showsCancelButton = YES;
    return YES;
}
</code></pre>
<h1 id="9-UITableView收起键盘"><a href="#9-UITableView收起键盘" class="headerlink" title="9.UITableView收起键盘"></a>9.UITableView收起键盘</h1><pre><code class="objective-c">// 方法1：
[self.view endEditing:YES];
// 方法2：
self.tableView.keyboardDismissMode = UIScrollViewKeyboardDismissModeOnDrag;
/// UIScrollView同样可以使用
</code></pre>
<h1 id="10-获取今天是星期几"><a href="#10-获取今天是星期几" class="headerlink" title="10.获取今天是星期几"></a>10.获取今天是星期几</h1><pre><code class="objective-c">+ (NSString *)getWeekDayStringWithDate:(NSDate *)date {
    NSCalendar * calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar];     // 指定日历的算法
    NSDateComponents *comps = [calendar components:NSWeekdayCalendarUnit fromDate:date];
    // 1 是周日，2是周一 3.以此类推
    NSNumber * weekNumber = @([comps weekday]);
    NSInteger weekInt = [weekNumber integerValue];
    NSString *weekDayString = @&quot;(周一)&quot;;
    switch (weekInt) {
        case 1:
        {
            weekDayString = @&quot;(周日)&quot;;
        }
            break;

        case 2:
        {
            weekDayString = @&quot;(周一)&quot;;
        }
            break;

        case 3:
        {
            weekDayString = @&quot;(周二)&quot;;
        }
            break;

        case 4:
        {
            weekDayString = @&quot;(周三)&quot;;
        }
            break;

        case 5:
        {
            weekDayString = @&quot;(周四)&quot;;
        }
            break;

        case 6:
        {
            weekDayString = @&quot;(周五)&quot;;
        }
            break;

        case 7:
        {
            weekDayString = @&quot;(周六)&quot;;
        }
            break;

        default:
            break;
    }
    return weekDayString;

}
</code></pre>
<h1 id="11-UIView的部分圆角问题"><a href="#11-UIView的部分圆角问题" class="headerlink" title="11.UIView的部分圆角问题"></a>11.UIView的部分圆角问题</h1><pre><code class="objective-c">UIView *view2 = [[UIView alloc] initWithFrame:CGRectMake(120, 10, 80, 80)];
view2.backgroundColor = [UIColor redColor];
[self.view addSubview:view2];

UIBezierPath *maskPath = [UIBezierPath bezierPathWithRoundedRect:view2.bounds byRoundingCorners:UIRectCornerBottomLeft | UIRectCornerBottomRight cornerRadii:CGSizeMake(10, 10)];
CAShapeLayer *maskLayer = [[CAShapeLayer alloc] init];
maskLayer.frame = view2.bounds;
maskLayer.path = maskPath.CGPath;
view2.layer.mask = maskLayer;
//其中，
byRoundingCorners:UIRectCornerBottomLeft | UIRectCornerBottomRight
//指定了需要成为圆角的角。该参数是UIRectCorner类型的，可选的值有：
* UIRectCornerTopLeft
* UIRectCornerTopRight
* UIRectCornerBottomLeft
* UIRectCornerBottomRight
* UIRectCornerAllCorners
</code></pre>
<h1 id="12-iOS画虚线"><a href="#12-iOS画虚线" class="headerlink" title="12.iOS画虚线"></a>12.iOS画虚线</h1><pre><code class="objective-c">// 记得先 QuartzCore框架的导入
#import &lt;QuartzCore/QuartzCore.h&gt;

CGContextRef context =UIGraphicsGetCurrentContext();  
CGContextBeginPath(context);  
CGContextSetLineWidth(context, 2.0);  
CGContextSetStrokeColorWithColor(context, [UIColor whiteColor].CGColor);  
CGFloat lengths[] = {10,10};  
CGContextSetLineDash(context, 0, lengths,2);  
CGContextMoveToPoint(context, 10.0, 20.0);  
CGContextAddLineToPoint(context, 310.0,20.0);  
CGContextStrokePath(context);  
CGContextClosePath(context); 
</code></pre>
<h1 id="13-UILabel多行显示"><a href="#13-UILabel多行显示" class="headerlink" title="13.UILabel多行显示"></a>13.UILabel多行显示</h1><pre><code class="objective-c">// 自动布局中多行UILabel，需要设置其preferredMaxLayoutWidth属性才能正常显示多行内容。另外如果出现显示不全文本，可以在计算的结果基础上＋0.5
CGFloat h = [model.message boundingRectWithSize:CGSizeMake([UIScreen mainScreen].bounds.size.width - kGAP-kAvatar_Size - 2*kGAP, CGFLOAT_MAX) options:NSStringDrawingUsesLineFragmentOrigin attributes:attributes context:nil].size.height + 0.5;
</code></pre>
<h1 id="14-禁止程序运行时自动锁屏"><a href="#14-禁止程序运行时自动锁屏" class="headerlink" title="14.禁止程序运行时自动锁屏"></a>14.禁止程序运行时自动锁屏</h1><pre><code class="objective-c">[[UIApplication sharedApplication] setIdleTimerDisabled:YES];
</code></pre>
<h1 id="15-MBProgressHUD的使用"><a href="#15-MBProgressHUD的使用" class="headerlink" title="15.MBProgressHUD的使用"></a>15.MBProgressHUD的使用</h1><pre><code class="objective-c">使用MBProgressHud时，尽量不要加到UIWindow上，加self.view上即可。如果加UIWindow上在iPad上，旋转屏幕的时候MBProgressHud不会旋转。之前有人遇到这个bug，我让他改放到self.view上即可解决此bug。
</code></pre>
<h1 id="16-强制让App直接退出（非闪退，非崩溃）"><a href="#16-强制让App直接退出（非闪退，非崩溃）" class="headerlink" title="16.强制让App直接退出（非闪退，非崩溃）"></a>16.强制让App直接退出（非闪退，非崩溃）</h1><pre><code class="objective-c">- (void)exitApplication {
    AppDelegate *app = [UIApplication sharedApplication].delegate;
    UIWindow *window = app.window;
    [UIView animateWithDuration:1.0f animations:^{
        window.alpha = 0;
    } completion:^(BOOL finished) {
        exit(0);
    }];
}
</code></pre>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS干货</tag>
      </tags>
  </entry>
  <entry>
    <title>Xcode中Other Linker Flags的作用</title>
    <url>/p/20171005-xcode-other-linker-flags.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><blockquote>
<p>在iOS开发中，经常会使用一些第三方的<strong>静态库</strong>（.a文件），有时候导入第三方类库 运行程序后你会发现：编译时可以正常编译，但运行时会app会闪退，报出selector not recognized的错误。</p>
</blockquote>
<ul>
<li><p>原因：静态库（.a文件）中使用了Category，而Objective-C的链接器并不会直接把静态库中的分类加载到最后的可执行文件中。所以程序在运行时，因找不到分类中的方法而闪退。</p>
</li>
<li><p>解决办法：</p>
<p>1》一般的第三方库的开发文档中都会写出这种问题的解决方法：如，在Build Settings——》Linking——》Other Liker Fliags中添加 <code>-ObjC</code> 或 <code>-all_load</code> 或 <code>-force_load</code> 等。</p>
<p>2》把类别文件添加进来（如果是第三方库，就不太现实）</p>
<p>3》在每个分类的 @implementation 前添加这个自定义宏：define BRSYNTH_DUMMY_CLASS( )</p>
<pre><code class="objective-c">/**
    静态库中编写 Category 时的便利宏，用于解决 Category 方法从静态库中加载需要特别设置的问题。
    加入这个宏后，不需要再在 Xcode 的 Other Liker Fliags 中设置链接库参数（-Objc / -all_load / -force_load）
    *******************************************************************************
    使用:在静态库中每个分类的 @implementation 前添加这个宏
    Example:
        #import &quot;NSString+BRAdd.h&quot;

        BRSYNTH_DUMMY_CLASS(NSString_BRAdd)
        @implementation NSString (BRAdd)
        @end
 */
#ifndef BRSYNTH_DUMMY_CLASS

    #define BRSYNTH_DUMMY_CLASS(_name_) \
    @interface BRSYNTH_DUMMY_CLASS_ ## _name_ : NSObject @end \
    @implementation BRSYNTH_DUMMY_CLASS_ ## _name_ @end

#endif

// 方法3是从源头上解决问题，需要修改库的源码。如果库是自己的，推荐这种方法。如果是别人的，只能使用方法1。
</code></pre>
</li>
</ul>
<p>思考：为什么要这样做呢? 为什么在编译时没有问题运行时就会报错？</p>
<ul>
<li>到这里，首先我们先引入一个链接器的概念 &gt;&gt;&gt;</li>
</ul>
<h1 id="链接器"><a href="#链接器" class="headerlink" title="链接器"></a>链接器</h1><p>还记得我们在学习C程序的时候，从C代码到可执行文件经历的步骤是：</p>
<pre><code>源代码 &gt; 预处理器 &gt; 编译器 &gt; 汇编器 &gt; 机器码 &gt; 链接器 &gt; 可执行文件
</code></pre><blockquote>
<p>在最后一步需要把.o文件和C语言运行库链接起来，这时候需要用到ld命令。源文件经过一系列处理以后，会生成对应的.obj文件，然后一个项目必然会有许多.obj文件，并且这些文件之间会有各种各样的联系，例如函数调用。</p>
<p>链接器做的事就是把这些目标文件和所用的一些库链接在一起形成一个完整的可执行文件。</p>
</blockquote>
<p>通过这个流程你也应该知道为什么在编译的过程中没事而在运行的时候就会报错了。</p>
<p>那我们为什么要设置Other Linker Flags呢？</p>
<ul>
<li>因为Other Linker Flags其实就是链接器工作时除了默认参数外的其他参数。</li>
</ul>
<h1 id="闪退的原因"><a href="#闪退的原因" class="headerlink" title="闪退的原因"></a>闪退的原因</h1><p>苹果官方Q&amp;A上有这么一段话：</p>
<blockquote>
<p>The “selector not recognized” runtime exception occurs due to an issue between the implementation of standard UNIX static libraries, the linker and the dynamic nature of Objective-C. Objective-C does not define linker symbols for each function (or method, in Objective-C) - instead, linker symbols are only generated for each class. If you extend a pre-existing class with categories, the linker does not know to associate the object code of the core class implementation and the category implementation. This prevents objects created in the resulting application from responding to a selector that is defined in the category. </p>
</blockquote>
<p>译：运行时的异常是由于静态库，链接器，与OC语言的动态特性之间的问题，Objective-C的链接器并不会为每个方法建立符号表，而只是对每一个类创建了符号表。如果一个类有了分类，那么链接器就不会将核心类与分类之间的代码进行合并，这样的话，在最后的可执行文件中，就会缺少分类里的代码，这样函数调用就失败了。</p>
<h1 id="链接器参数"><a href="#链接器参数" class="headerlink" title="链接器参数"></a>链接器参数</h1><p>在前面我们说如果出现问题要在Other Linker Flags中加入 <code>-ObjC</code> 或者 <code>-all_load</code> 或者 <code>-force_load</code> ，我们为什么要加入这样的参数呢，他们究竟做了什么事呢？下面就是对这三个参数的一个讲解。</p>
<ul>
<li><p><strong>-ObjC</strong> </p>
<blockquote>
<p>作用是：让链接器把静态库中所有的Objective-C类和分类都加载到最后的可执行文件中。</p>
<p>如果静态库中有类和category，只能加入这个参数才行；</p>
<p>如果静态库中只有分类而没有类，-Objc就失效了，这就需要使用-all_load或者-force_load了。 </p>
</blockquote>
</li>
<li><p><strong>-all_load</strong> </p>
<blockquote>
<p>作用是：让链接器把所有找到的目标文件（可能是多个静态库文件）都加载到可执行文件中。</p>
<p>这个参数也有一个弊端，那就是你使用了不止一个静态库文件，那么你很有可能会遇到ld: duplicate symbol错误，因为不同的库文件里面可能会有相同的目标文件，所以建议在遇到-ObjC失效的情况下使用-force_load参数。</p>
</blockquote>
</li>
<li><p><strong>-force_load</strong></p>
<blockquote>
<p>所做的事情跟-all_load其实是一样的，只是-force_load需要指定要进行全部加载的库文件的路径，这样的话，你就只是完全加载了一个库文件，不影响其余库文件的按需加载。</p>
</blockquote>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>个人建议ObjC与force_load搭配使用比较好。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS干货</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS中常见的宏</title>
    <url>/p/20171004-ios-define.html</url>
    <content><![CDATA[<h1 id="自定义宏"><a href="#自定义宏" class="headerlink" title="自定义宏"></a>自定义宏</h1><ul>
<li>处理NSLog事件(开发者模式打印,发布者模式不打印)</li>
</ul>
<pre><code class="objective-c">#ifdef DEBUG
  #define NSLog(FORMAT, ...) fprintf(stderr, &quot;[%s(%d):%s]\t%s\n&quot;,[[[NSString stringWithUTF8String:__FILE__] lastPathComponent] UTF8String], __LINE__, __func__, [[NSString stringWithFormat:FORMAT, ##__VA_ARGS__] UTF8String]);
#else
  #define NSLog(FORMAT, ...) nil
#endif
</code></pre>
<ul>
<li>只在OC语言的情况下引用</li>
</ul>
<pre><code class="objective-c">// 保证 #ifdef 中的内容只会在 ObjectivObjective-C，在 C/C++ 代码中不会被引用
#ifdef __OBJC__
   // 定义宏或导入头文件
#endif
</code></pre>
<ul>
<li>判断当前的iPhone设备/系统版本</li>
</ul>
<pre><code class="objective-c">//判断是否为iPhone
#define IS_IPHONE (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPhone)
//判断是否为iPad
#define IS_IPAD (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad)
//判断是否为ipod
#define IS_IPOD ([[[UIDevice currentDevice] model] isEqualToString:@&quot;iPod touch&quot;])
//获取系统版本
#define IOS_SYSTEM_VERSION [[[UIDevice currentDevice] systemVersion] floatValue]
</code></pre>
<ul>
<li>使用 ARC 和 MRC</li>
</ul>
<pre><code class="objective-c">#if __has_feature(objc_arc)
    // ARC
#else
    // MRC
#endif
</code></pre>
<ul>
<li>宏与const 的使用</li>
</ul>
<pre><code>宏的用法：一般定义代码就用宏。
const用法：一般定义一个常量字符串就用const（如，服务器的地址）。
static NSString * const server_host = @&quot;api.apple.com&quot;;
</code></pre><ul>
<li>判断当前设备是模拟器还是真机</li>
</ul>
<pre><code class="objective-c">#if TARGET_IPHONE_SIMULATOR  
    // 模拟器  
#elif TARGET_OS_IPHONE  
    // 真机  
#endif  
</code></pre>
<ul>
<li>判断当前设备系统</li>
</ul>
<pre><code class="objective-c">#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_8_0  
    // 这里写设备系统大于8.0 以上的代码  
#else  
    // 这里写设备系统小于8.0以上的代码  
#endif 


#if __IPHONE_OS_VERSION_MIN_REQUIRED &lt;= __IPHONE_7_0  
    // 这里写设备系统小于7.0以上的代码  
#else  
    // 这里写设备系统大于7.0以上的代码  
#endif 
</code></pre>
<ul>
<li>设置随机颜色</li>
</ul>
<pre><code class="objective-c">#define GRandomColor [UIColor colorWithRed:arc4random_uniform(256)/255.0 green:arc4random_uniform(256)/255.0 blue:arc4random_uniform(256)/255.0 alpha:1.0]
</code></pre>
<ul>
<li>静态库(.a文件)中有分类，调用分类中的方法 crash</li>
</ul>
<pre><code class="objective-c">/**
    静态库中编写 Category 时的便利宏，用于解决 Category 方法从静态库中加载需要特别设置的问题。
    加入这个宏后，不需要再在 Xcode 的 Other Liker Fliags 中设置链接库参数（-Objc / -all_load / -force_load）
    *******************************************************************************
    使用:在静态库中每个分类的 @implementation 前添加这个宏
    Example:
        #import &quot;NSString+BRAdd.h&quot;

        BRSYNTH_DUMMY_CLASS(NSString_BRAdd)
        @implementation NSString (BRAdd)
        @end
 */
#ifndef BRSYNTH_DUMMY_CLASS

    #define BRSYNTH_DUMMY_CLASS(_name_) \
    @interface BRSYNTH_DUMMY_CLASS_ ## _name_ : NSObject @end \
    @implementation BRSYNTH_DUMMY_CLASS_ ## _name_ @end

#endif

// 在ios开发过程中，有时候会用到第三方的静态库(.a文件)，OC没有为每个函数（或者方法）定义链接符号，它只为每个类创建链接符号。这样当在一个静态库中使用类别来扩展已有类的时候，链接器不知道如何把类原有的方法和类别中的方法整合起来，就会导致你调用类别中的方法时，会出现selector not recognized的错误，从而导致app闪退。使用这段宏定义他可以虚拟新建一个与名字category 相同.h.m 让编译器 编译通过。即可解决上面的问题。
</code></pre>
<ul>
<li>合成弱引用或者强引用。</li>
</ul>
<pre><code class="objective-c">/**
 Synthesize a weak or strong reference.

 Example:
    @weakify(self)
    [self doSomething^{
        @strongify(self)
        if (!self) return;
        ...
    }];

 */

#ifndef weakify
    #if DEBUG
        #if __has_feature(objc_arc)
        #define weakify(object) autoreleasepool{} __weak __typeof__(object) weak##_##object = object;
        #else
        #define weakify(object) autoreleasepool{} __block __typeof__(object) block##_##object = object;
        #endif
    #else
        #if __has_feature(objc_arc)
        #define weakify(object) try{} @finally{} {} __weak __typeof__(object) weak##_##object = object;
        #else
        #define weakify(object) try{} @finally{} {} __block __typeof__(object) block##_##object = object;
        #endif
    #endif
#endif

#ifndef strongify
    #if DEBUG
        #if __has_feature(objc_arc)
        #define strongify(object) autoreleasepool{} __typeof__(object) object = weak##_##object;
        #else
        #define strongify(object) autoreleasepool{} __typeof__(object) object = block##_##object;
        #endif
    #else
        #if __has_feature(objc_arc)
        #define strongify(object) try{} @finally{} __typeof__(object) object = weak##_##object;
        #else
        #define strongify(object) try{} @finally{} __typeof__(object) object = block##_##object;
        #endif
    #endif
#endif
</code></pre>
<ul>
<li>断言</li>
</ul>
<pre><code class="objective-c">// 1.NSAssert / NSCAssert 的用法（如果条件为假,就会抛出异常）
// 前者适用于Objective-C的方法,后者适用于C的函数。
int a = 4;  
NSAssert(a == 5, @&quot;a must equal to 5&quot;); //第一个参数是条件,如果条件为假,就会抛出异常并打印第二个参数的内容
// 注意：NSAssert 的定义中有self（即持有self的strong引用），在block中使用时要避免出现循环引用问题。NSCAssert 的用法与 NSAssert 一致，适用于C语言的函数，在OC中也可以使用，并且没有持有self，在block中使用不会出现循环引用问题

// 2.NSParameterAssert / NSCparameterAssert 的用法(是针对参数是否存在的断言)
// 前者适用于Objective-C的方法,后者适用于C的函数。
- (void)assertWithPara:(NSString *)str {  
    NSParameterAssert(str); //只需要一个参数,如果参数存在程序继续运行,如果参数为空,则程序停止并打印日志  
    //further code ...  
}

// Xcode 已经默认将release环境下的断言取消了, 免除了忘记关闭断言造成的程序不稳定。

// 常用的几个自定义断言
#define BRAssertNil(condition, description, ...) NSAssert(!(condition), (description), ##__VA_ARGS__)
#define BRCAssertNil(condition, description, ...) NSCAssert(!(condition), (description), ##__VA_ARGS__)

#define BRAssertNotNil(condition, description, ...) NSAssert((condition), (description), ##__VA_ARGS__)
#define BRCAssertNotNil(condition, description, ...) NSCAssert((condition), (description), ##__VA_ARGS__)

#define BRAssertMainThread() NSAssert([NSThread isMainThread], @&quot;This method must be called on the main thread&quot;)
#define BRCAssertMainThread() NSCAssert([NSThread isMainThread], @&quot;This method must be called on the main thread&quot;)
</code></pre>
<h1 id="系统宏"><a href="#系统宏" class="headerlink" title="系统宏"></a>系统宏</h1><ul>
<li>NS_AVAILABLE_IOS 与 NS_DEPRECATED_IOS</li>
</ul>
<pre><code class="objective-c">// 在iOS系统的API中，我们经常会看到下面的一些宏
- (CGRect)boundingRectWithSize:(CGSize)size options:(NSStringDrawingOptions)options attributes:(nullable NSDictionary&lt;NSAttributedStringKey, id&gt; *)attributes context:(nullable NSStringDrawingContext *)context NS_AVAILABLE(10_11, 7_0);

- (CGSize)sizeWithFont:(UIFont *)font constrainedToSize:(CGSize)size lineBreakMode:(NSLineBreakMode)lineBreakMode NS_DEPRECATED_IOS(2_0, 7_0, &quot;Use -boundingRectWithSize:options:attributes:context:&quot;) __TVOS_PROHIBITED;

/**
    含义：(AVAILABLE：可用； DEPRECATED：弃用)
    NS_AVAILABLE(10_11, 7_0) 表示自 Mac10.11 和 iOS7.0 引入该函数，即 iOS7之后 使用这个函数
    NS_AVAILABEL_IOS(6_0) 表示自 iOS6.0 引入该方法，若在iOS6.0之前的版本使用该函数，则会导致 Crash；
    NS_DEPRECATED_IOS(2_0, 7_0, &quot;替代函数&quot;)  表示该函数自 iOS2.0 引入，在 iOS7.0 被废弃。推荐 iOS7.0 之后使用替代函数。
    NS_DEPRECATED(10_6, 10_9, 2_0, 7_0) 表示自 Mac10.6 和 iOS2.0 引入，在 Mac10.9 和 iOS7.0 被废弃
 */
</code></pre>
<ul>
<li>忽略编译器警告宏</li>
</ul>
<pre><code class="objective-c">// 处理编译器警告(下面 #pragma 的作用是，去掉方法的警告提示)
#pragma clang diagnostic push
#pragma clang diagnostic ignored &quot;-Wdeprecated-declarations&quot;

CGSize size = [self sizeWithFont:font constrainedToSize:maxSize lineBreakMode:lineBreakMode];

#pragma clang diagnostic pop
</code></pre>
<ul>
<li>全局设置 <code>nonnull</code> 类型的宏</li>
</ul>
<pre><code class="objective-c">NS_ASSUME_NONNULL_BEGIN

/**
 Provides extensions for `UIBarButtonItem`.
 */
@interface UIBarButtonItem (YYAdd)

/**
 The block that invoked when the item is selected. The objects captured by block
 will retained by the ButtonItem.

 @discussion This param is conflict with `target` and `action` property.
 Set this will set `target` and `action` property to some internal objects.
 */
@property (nullable, nonatomic, copy) void (^actionBlock)(id);

@end

NS_ASSUME_NONNULL_END
</code></pre>
<p><code>NS_ASSUME_NONNULL_BEGIN</code> 和 <code>NS_ASSUME_NONNULL_END</code> 两个宏之间的代码，所有指针对象都被假定为nonnull， 即不能为空，否则编辑器会报警告 <code>Null passed to a callee that requires a non-null argument</code>。</p>
<blockquote>
<p>该段代码使用了 <code>NS_ASSUME_NONNULL_BEGIN</code> , <code>NS_ASSUME_NONNULL_END</code></p>
<p>两个宏中间包含的属性，参数值，返回值，默认是 <code>nonnull</code> 类型。</p>
<p>如果想要某个属性，参数值或者返回值为可选类型，则单独在该属性，参数值，或者返回值前单独标明<code>nullable</code>。</p>
</blockquote>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>宏</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS中关于日历和日期的计算</title>
    <url>/p/20171003-ios-calendar-date.html</url>
    <content><![CDATA[<h1 id="1-获取当前时间"><a href="#1-获取当前时间" class="headerlink" title="1.获取当前时间"></a>1.获取当前时间</h1><pre><code class="objective-c">NSCalendar *calendar = [NSCalendar currentCalendar];
NSDateComponents  *components  =  [calendar components:NSCalendarUnitMinute | NSCalendarUnitMonth | NSCalendarUnitHour | NSCalendarUnitDay fromDate:[NSDate date]];
NSLog(@&quot;%ld月%ld日%ld时%ld分&quot; ,(long)components.month,(long)components.day,(long)components.hour,(long)components.minute);
</code></pre>
<h1 id="2-查看今天是在今年的第几周"><a href="#2-查看今天是在今年的第几周" class="headerlink" title="2.查看今天是在今年的第几周"></a>2.查看今天是在今年的第几周</h1><pre><code class="objective-c">NSCalendar *calendar1 = [NSCalendar currentCalendar];
NSInteger week = [calendar1 ordinalityOfUnit:NSCalendarUnitWeekday inUnit:NSCalendarUnitYear forDate:[NSDate date]];
NSLog(@&quot;今天是今年的第%ld周&quot;,(long)week);
</code></pre>
<h1 id="3-现在往后3天2小时"><a href="#3-现在往后3天2小时" class="headerlink" title="3.现在往后3天2小时"></a>3.现在往后3天2小时</h1><pre><code class="objective-c">NSDateComponents * components2 = [[NSDateComponents alloc] init];
components2.year = 0;
components2.day = 3;
components2.hour = 2;
NSCalendar *calendar3 = [NSCalendar currentCalendar];
NSDate *currentDate = [NSDate date];
NSDate *nextData = [calendar3 dateByAddingComponents:components2 toDate:currentDate options:NSCalendarMatchStrictly];
NSDateFormatter * formatter1 = [[NSDateFormatter alloc] init];
formatter1.dateFormat = @&quot;yyyy年MM月dd日hh时mm分ss秒&quot;;
NSString * str1 = [formatter1 stringFromDate:nextData];
NSLog(@&quot;%@&quot;,str1);
</code></pre>
<h1 id="4-需求：一天执行一次某个操作"><a href="#4-需求：一天执行一次某个操作" class="headerlink" title="4.需求：一天执行一次某个操作"></a>4.需求：一天执行一次某个操作</h1><pre><code class="objective-c">- (void)setToday:(NSString *)userDefaultsName{
// 存储当前时间
NSCalendar *calendar0 = [NSCalendar currentCalendar];
NSDateComponents *components = [calendar0 components:(NSCalendarUnitYear|NSCalendarUnitMonth|NSCalendarUnitDay) fromDate:[NSDate date]];
NSInteger currentIndex = [[NSString stringWithFormat:@&quot;%ld%ld%ld&quot;,(long)components.year,(long)components.month,(long)components.day] integerValue];
NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];
[userDefaults setInteger:currentIndex forKey:userDefaultsName];
[userDefaults synchronize];
}

// 检测userDefaultsName对应的时间和当前时间相比是否已经超出了一天 yes为已经超出
+(BOOL)exceedOneDay:(NSString *)userDefaultsName{
// 取出保存的时间和当前时间进行比较看是否超出一天
NSCalendar *calendar0 = [NSCalendar currentCalendar];
NSDateComponents *components = [calendar0 components:(NSCalendarUnitYear|NSCalendarUnitMonth|NSCalendarUnitMonth) fromDate:[NSDate date]];
NSInteger todayTimeInDay = [[NSString stringWithFormat:@&quot;%ld%ld%ld&quot;,components.year,components.month,components.day]integerValue];
NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];
NSInteger lastTimeInDay = [userDefaults integerForKey:userDefaultsName];

if (todayTimeInDay&gt;lastTimeInDay) {
    // 超出一天
    return YES;
}
return NO;
}
</code></pre>
<h1 id="5-在某个界面上显示VIP的截止时间，VIP的时间是一个月"><a href="#5-在某个界面上显示VIP的截止时间，VIP的时间是一个月" class="headerlink" title="5.在某个界面上显示VIP的截止时间，VIP的时间是一个月"></a>5.在某个界面上显示VIP的截止时间，VIP的时间是一个月</h1><pre><code class="objective-c">static NSString *const limitDate = @&quot;limitDate&quot;;
static NSString *const formatPaymentTime = @&quot;formatPaymentTime&quot;;
+ (NSString *)persistLimitTime:(NSString *)paymentTime{

// 加这一句的目的是因为在支付时候本地的时间格式是下面的样子，
// 由于项目需求要用到YYYY-MM-dd这种格式
NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
[formatter setDateFormat:@&quot;YYYYMMddHHmmss&quot;];

NSDate *currentPayTime = [formatter dateFromString:paymentTime];
NSDate *recordDate = [[NSUserDefaults standardUserDefaults] objectForKey:limitDate];

[formatter setDateFormat:@&quot;YYYY-MM-dd&quot;];
formatter.timeZone = [NSTimeZone defaultTimeZone];

NSCalendar *calender = [[NSCalendar alloc] initWithCalendarIdentifier:NSCalendarIdentifierGregorian];
// 时间比较，这个目的是有可能续费，截至时间需要叠加
if (recordDate) {
    NSComparisonResult result = [calender compareDate:currentPayTime toDate:recordDate toUnitGranularity:NSCalendarUnitYear | NSCalendarUnitMonth | NSCalendarUnitDay];
    if (result==NSOrderedAscending) {
        currentPayTime = recordDate;//截止时间大于当前支付时间
    }
}

// 加一个月，VIP 周期
NSDateComponents *monthComponent = [[NSDateComponents alloc] init];
[monthComponent setMonth:+1];
[monthComponent setYear:0];
[monthComponent setDay:0];

NSDate *toDate = [calender dateByAddingComponents:monthComponent toDate:currentPayTime options:0];
NSDateComponents *component = [calender components:NSCalendarUnitYear | NSCalendarUnitMonth | NSCalendarUnitDay fromDate:toDate];
NSDate *dateNew = [calender dateFromComponents:component];
paymentTime = [formatter stringFromDate:dateNew];

[[NSUserDefaults standardUserDefaults] setObject:dateNew forKey:limitDate];
[[NSUserDefaults standardUserDefaults] setObject:paymentTime forKey:formatPaymentTime];
[[NSUserDefaults standardUserDefaults] synchronize];

return paymentTime;
}

// 判断VIP是否过期  YES:过期/NO:没过期
+ (BOOL)isExpried {

NSCalendar *calender = [[NSCalendar alloc] initWithCalendarIdentifier:NSCalendarIdentifierGregorian];
NSDate *recordDate = [[NSUserDefaults standardUserDefaults] objectForKey:limitDate];

// 时间比较
if (recordDate) {
    NSComparisonResult result = [calender compareDate:[NSDate date] toDate:recordDate toUnitGranularity:NSCalendarUnitYear | NSCalendarUnitMonth | NSCalendarUnitDay];
    return result==NSOrderedDescending?YES:NO;

}
return YES;

}
</code></pre>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>NSCalendar</tag>
      </tags>
  </entry>
  <entry>
    <title>苹果开发者账号申请流程</title>
    <url>/p/20171003-apple-developer-account-process.html</url>
    <content><![CDATA[<h1 id="1-账号类型"><a href="#1-账号类型" class="headerlink" title="1.账号类型"></a>1.账号类型</h1><ul>
<li>个人账号：以个人名义申请的开发者账号，仅限于个人使用，可以在 App Store 发布应用，申请比较容易，￥688.00/年（$99.00/年）。</li>
<li>公司账号：以公司名义申请的开发者账号，用于公司内部的开发者共用，可以在 App Store 发布应用，申请流程相对麻烦，￥688.00/年（$99.00/年）。</li>
<li>企业账号：一般是公司规模在 500 人以上的企业，用于内部测试、分发应用的账号，<strong>不能在 App Store 发布应用</strong>，申请流程相对麻烦，￥1988/年（$299.00/年）。</li>
</ul>
<h1 id="2-申请准备"><a href="#2-申请准备" class="headerlink" title="2.申请准备"></a>2.申请准备</h1><ul>
<li><p>个人开发者账号：</p>
<ul>
<li>注册邮箱（手机号，验证码，密码）</li>
<li>注册苹果账号：Apple ID（邮箱，密码，姓名，生日）</li>
<li>加入开发者并且付款（visa或者万事达信用卡）</li>
</ul>
<blockquote>
<p>申请结束之后需要等待审核，由于公司比较急，我就给苹果客服打了电话(4006 701 855)，客户需要和appid所有者进行沟通核实，之后马上就可以审核成功</p>
</blockquote>
</li>
<li><p>公司开发者账号：</p>
<ul>
<li>注册邮箱（手机号，验证码，密码）</li>
<li>注册苹果账号：Apple ID（邮箱，密码，姓名，生日）</li>
<li>加入开发者：<ul>
<li>邓白氏编码申请：（有直接填写，没有需要申请）公司法人姓名，公司英文名，公司地址（街道，市，省），邮编，联系电话，申请者姓名，电话，邮箱。</li>
<li>同事的姓名职位，邮箱，电话，用于验证信息</li>
<li>公司英文名，公司邓白氏编码，公司网址，老板电话，申请者邮箱 </li>
<li>只能用visa或者万事达国际信用卡</li>
</ul>
</li>
</ul>
<blockquote>
<p>邓白氏编码申请成功后，邓白氏公司会给申请者的邮箱发送提示邮件，给邓白氏打了电话 4008 202 669 可以查询相关信息。</p>
</blockquote>
</li>
</ul>
<h1 id="3-申请步骤"><a href="#3-申请步骤" class="headerlink" title="3.申请步骤"></a>3.申请步骤</h1><ul>
<li><p>2.1 打开 Apple 开发者账号申请链接地址：<a href="https://developer.apple.com/programs/" target="_blank" rel="noopener">https://developer.apple.com/programs/</a></p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fqzcdvfdfuj30yg0uy0wb.jpg" alt="申请链接页面"></p>
<p>点击Enroll(上图红框中按钮)，进入申请页面：</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fqzcet7s4gj30yg10z41r.jpg" alt="申请页面"></p>
</li>
<li><p>2.2 上面的页面介绍了开发者账号的种类，以及申请每个种类账号所需做的准备。点击Start Your Enrollment,进入下一页面。</p>
</li>
<li><p>2.3 如果您此时没有登录，会跳转到登录页面先登录您的 Apple ID。之后进入下面的页面：</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fqzcfgl2rdj30yg0n2jso.jpg" alt="类型选择页面"></p>
<blockquote>
<p>点击红框内的选项框，可看到如下选项：</p>
</blockquote>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fqzcgccypcj30yg086gm1.jpg" alt="类型选择框"></p>
<blockquote>
<p>选择红框内的Company / Organization，您将看到如下提示：</p>
</blockquote>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fqzcgvp26wj30yg0pojv1.jpg" alt="类型选择提示"></p>
</li>
<li><p>2.4 这些提示描述了加入公司开发者计划所需要具备的条件。</p>
<ul>
<li>特别注意的是，您的公司必须拥有一个邓白氏码(D-U-N-S? Number)。</li>
<li>如果您的公司拥有一个，在后面的步骤中，直接填写即可。</li>
<li>如您不清楚，可以点击上图红框中的Check now &gt;，浏览器会为您新建一个窗口／标签，跳转到如下页面：</li>
</ul>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fqzchn5s2hj30yg13ygo3.jpg" alt="检查邓白氏码"></p>
<blockquote>
<p>请按照下面的提示填写相关信息：</p>
</blockquote>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fqzci1rmg4j30yg1h8jul.jpg" alt="邓白氏信息填写"></p>
<blockquote>
<ol>
<li><p><strong>Country</strong>：点击，选择 China</p>
</li>
<li><p><strong>Legal Entity Name</strong>：填写公司完整的英文名称，如：Hangzhou xxxx<br>Technology Co., Ltd.</p>
<p>———————Headquarters Address（公司总部地址）————————</p>
</li>
<li><p><strong>Street Address</strong>：填写公司街道详细地址，要与营业执照内容一致</p>
</li>
<li><p><strong>Town / City</strong>：填写公司所在城市（市或者区），如：Hangzhou</p>
</li>
<li><p><strong>State / Province</strong>：点击，选择公司所在省份（直辖市或者省），如：Zhejiang</p>
</li>
<li><p><strong>Postal Code</strong>：填写邮政编码</p>
</li>
<li><p><strong>Phone Number</strong>：联系手机号。先点击，选择86，再填写手机号</p>
<p>————–Your Contact Information（你的联系信息）——————</p>
<p>提示：可填写负责申请邓氏编码工作人员的联系信息，后续处理会直接联系此项上填的信息</p>
</li>
<li><p><strong>Given Name</strong>：填写名字</p>
</li>
<li><p><strong>Family Name</strong>：填写姓氏</p>
</li>
<li><p><strong>Work Phone Number</strong>：你的工作电话</p>
</li>
<li><p><strong>Work Email</strong>：你的邮箱（国内的是华夏邓白氏代理，后续他们会直接联系这个邮件地址）</p>
</li>
<li><p>输入上图的验证码</p>
</li>
<li><p>提交，提示未找到你的组织。确认组织信息，再点击“submit”</p>
</li>
</ol>
</blockquote>
</li>
<li><p>2.5 完成上面的步骤后，如果您的公司已经拥有邓白氏码，将在一步确认之后，发送到您填写的工作邮箱中；如果没有，可以将这个信息提交到邓白氏公司，经审核后会得到邓白氏码。</p>
<ul>
<li><p>然后就是等待，大概2、3天时间，华夏邓白氏公司会给你发邮件要你提供公司完整真实信息。回复他后就等着那边继续做后续事项了。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fqzcj8tnrqj30hw0f1aav.jpg" alt="公司信息"></p>
</li>
<li><p>过了1天左右会再次发邮件通知你审核完成了。过个2周左后就可以使用邓氏编码了。</p>
</li>
</ul>
</li>
<li><p>2.6 拥有邓氏编码后，继续回到这个页面：</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fqzcjocj2cj30yg0sg77w.jpg" alt="类型选择提示"></p>
<blockquote>
<p>点击Continue，进入下一页，填写相关信息。</p>
</blockquote>
</li>
<li><p>2.7 由于信息较多，将页面分别截图，并提示填写。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fqzck2udf1j30yg10k0w9.jpg" alt="个人信息填写"></p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fqzckirhwpj30yg0xttaz.jpg" alt="组织信息填写"></p>
</li>
<li><p>2.8 以上信息填写完成后，点击红框内的Continue,进入下一页面。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fqzcl47v59j30yg18qgo1.jpg" alt="信息确认"></p>
<blockquote>
<p>这个页面为最后的信息确认页面，如信息无误，按照图中提示操作，并点击红框内的Submit提交。</p>
</blockquote>
</li>
<li><p>2.9 完成以后，等待苹果公司的确认电话，电话中会核实相关信息，确认完成后，即可填写信用卡信息，缴费，完成申请。</p>
</li>
<li><p>2.10 申请期间有任何疑问，可以拨打苹果开发者中心的电话400-670-1855咨询。</p>
<blockquote>
<p>注：所有过程中，只有在接到苹果公司电话后缴纳开发者计划的首年年费￥688.00，其他步骤均不收费。</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>开发者账号</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+github 搭建个人技术博客</title>
    <url>/p/20171001-hexo-github-blog.html</url>
    <content><![CDATA[<h1 id="什么是Hexo？"><a href="#什么是Hexo？" class="headerlink" title="什么是Hexo？"></a>什么是Hexo？</h1><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<ul>
<li>官方文档：<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></li>
</ul>
<h1 id="1-安装Hexo"><a href="#1-安装Hexo" class="headerlink" title="1.安装Hexo"></a>1.安装Hexo</h1><p>安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序：</p>
<ul>
<li><a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a></li>
<li><a href="http://git-scm.com/" target="_blank" rel="noopener">Git</a></li>
</ul>
<p>如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。<br>终端输入：(一定要加上sudo，否则会因为权限问题报错)</p>
<pre><code class="bash">$ sudo npm install -g hexo-cli
</code></pre>
<p>终端输入：查看安装的版本，检查是否已安装成功！</p>
<pre><code class="bash">$ hexo -v  // 显示 Hexo 版本
</code></pre>
<h1 id="2-建站"><a href="#2-建站" class="headerlink" title="2.建站"></a>2.建站</h1><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p>
<pre><code class="bash">// 新建空文件夹
$ cd /Users/renbo/Workspaces/BlogProject
// 初始化
$ hexo init 
$ npm install
</code></pre>
<p>新建完成后，指定文件夹的目录如下：</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fqzcbed62lj30bi07waal.jpg" alt="目录结构图"></p>
<ul>
<li><strong>_config.yml</strong>：网站的 <a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="noopener">配置</a> 信息，您可以在此配置大部分的参数。</li>
<li><strong>scaffolds</strong>：<a href="https://hexo.io/zh-cn/docs/writing.html" target="_blank" rel="noopener">模版</a> 文件夹。当您新建文章（即新建markdown文件）时，Hexo 会根据 scaffold 来建立文件。</li>
<li><strong>source</strong>：资源文件夹是存放用户资源（即markdown文件）的地方。</li>
<li><strong>themes</strong>：<a href="https://hexo.io/zh-cn/docs/themes.html" target="_blank" rel="noopener">主题</a> 文件夹。Hexo 会根据主题来生成静态页面。</li>
</ul>
<h1 id="3-新建博客文章"><a href="#3-新建博客文章" class="headerlink" title="3.新建博客文章"></a>3.新建博客文章</h1><p>新建一篇文章（即新建markdown文件）指令：</p>
<pre><code class="bash">$ hexo new &quot;文章标题&quot;
</code></pre>
<h1 id="4-生成静态文件"><a href="#4-生成静态文件" class="headerlink" title="4.生成静态文件"></a>4.生成静态文件</h1><p>将文章markdown文件按指定格式生成静态网页文件</p>
<pre><code class="bash">$ hexo g  // g 表示 generate ，是简写
</code></pre>
<h1 id="5-部署网站"><a href="#5-部署网站" class="headerlink" title="5.部署网站"></a>5.部署网站</h1><p>即将生成的网页文件上传到网站服务器（这里是上传到Github）。</p>
<ul>
<li><p>上传之前可以先启动本地服务器（指令：<code>hexo s</code> ），在本地预览生成的网站。</p>
<p>默认本地预览网址：<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></p>
<pre><code class="bash">$ hexo s  // s 表示 server，是简写
</code></pre>
</li>
<li><p>部署网站指令：</p>
<pre><code class="bash">$ hexo d  // d 表示 deploy，是简写
</code></pre>
</li>
<li><p>注意，如果报错： <code>ERROR Deployer not found: git</code></p>
<p>需要我们再安装一个插件：</p>
<pre><code class="bash">$ sudo npm install hexo-deployer-git --save
</code></pre>
<p>安装完插件之后再执行一下【hexo d】,它就会开始将public文件夹下的文件全部上传到你的gitHub仓库中。</p>
</li>
</ul>
<h1 id="6-清除文件"><a href="#6-清除文件" class="headerlink" title="6.清除文件"></a>6.清除文件</h1><p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public目录下的所有文件</code>)。</p>
<p>清除指令：（一般是更改不生效时使用）</p>
<pre><code class="bash">$ hexo clean
</code></pre>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
      </tags>
  </entry>
</search>
